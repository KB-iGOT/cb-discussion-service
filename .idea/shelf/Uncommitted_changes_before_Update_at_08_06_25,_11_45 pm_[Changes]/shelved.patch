Index: src/main/resources/application.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>server.connection-timeout=5000\nserver.tomcat.max-threads=2048\nserver.tomcat.min-spare-threads=20\nserver.tomcat.max-connections=15000\nserver.tomcat.accept-count=500\nserver.port=7001\n\n#spring data jpa for postgres\nspring.datasource.url=jdbc:postgresql://localhost:5432/sunbird\nspring.datasource.username=\nspring.datasource.password=\nspring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect\nspring.jpa.properties.hibernate.format_sql=true\nspring.jpa.show-sql=false\n# Hibernate ddl auto (create, create-drop, validate, update)\nspring.jpa.hibernate.ddl-auto = update\n\nspring.cassandra.local-datacenter=DC1\nsunbird_cassandra_consistency_level=ONE\n\ncassandra.config.host=localhost\n\nspring.redis.host=localhost\nspring.redis.port=6379\nspring.redis.password=\nspring.redis.cacheTtl= 60000\nsearch.result.redis.ttl=600\n\nelasticsearch.host=localhost\nelasticsearch.port=9200\nelasticsearch.username=\nelasticsearch.password=\nelastic.required.field.discussion.json.path=/EsFieldsmapping/discussionEsMapping.json\nelastic.required.field.community.json.path=/EsFieldsmapping/communityEsFilePath.json\n\n#kafka Server\nspring.kafka.bootstrap.servers=localhost:9092\n#kafka properties\nkakfa.offset.reset.value=latest\nkafka.max.poll.interval.ms=15000\nkafka.max.poll.records=100\nkafka.auto.commit.interval.ms=10000\n\nsso.url=https://portal.dev.karmayogibharat.net/auth/\nsso.realm=sunbird\nsso.connection.pool.size=20\nsso.enabled=true\ndiscussion.entity=discussion_entity_alias\ncommunity.entity=community_entity_alias\n\ncloud.storage.type.name=azure\ncloud.storage.key=igot\ncloud.storage.secret=cloudStorageKey\ncloud.storage.endpoint=endpoint\ndiscussion.cloud.folder.name=discussionhub\ndiscussion.container.name=igot\n\naccesstoken.publickey.basepath=\nkafka.topic.community.discusion.post.count.group=dev.community.discusion.post.count.group\nkafka.topic.community.discusion.post.count=dev.community.discusion.post.count\nkafka.topic.community.discusion.like.count.group=dev.community.discusion.like.count.group\nkafka.topic.community.discusion.like.count=dev.community.discusion.like.count\nreport.post.user.limit=5\ndiscussion.es.defaultPageSize=10\ndiscussion.feed.redis.ttl=3600\ndiscussion.report.hide.post = true\n\ndiscussionValidation=/payloadValidation/discussionValidation.json\ndiscussionUpdateValidation=/payloadValidation/discussionUpdateValidation.json\ndiscussionAnswerPostValidation=/payloadValidation/discussionAnswerPostValidation.json\nanswerPostUpdateValidation=/payloadValidation/answerPostUpdateValidation.json\nanswerPostReplyValidation=/payloadValidation/answerPostReplyValidation.json\nanswerPostReplyUpdateValidation=/payloadValidation/answerPostReplyUpdateValidation.json\n\nspring.servlet.multipart.max-file-size= 50MB\nspring.servlet.multipart.max-request-size= 50MB\n\nspring.redis.data.host=localhost\nspring.redis.data.port=6379\n\nfilter.criteria.global.feed={\"filterCriteriaMap\":{\"type\":\"question\"},\"requestedFields\":[],\"pageNumber\":0,\"pageSize\":10,\"orderBy\":\"updatedOn\",\"orderDirection\":\"DESC\",\"facets\":[]}\nfilter.criteria.trending.feed={\"filterCriteriaMap\":{\"type\":\"question\"},\"requestedFields\":[],\"pageSize\":3,\"orderBy\":\"answerPostCount\",\"orderDirection\":\"DESC\",\"facets\":[]}\nfilter.criteria.mdo.all.report.feed={\"filterCriteriaMap\":{\"type\":[\"question\",\"answerPost\",\"answerPostReply\"],\"status\":[\"reported\"]},\"requestedFields\":[],\"pageSize\":10,\"orderBy\":\"recentReportedOn\",\"orderDirection\":\"DESC\",\"facets\":[\"type\"]}\nfilter.criteria.mdo.report.question.feed={\"filterCriteriaMap\":{\"type\":[\"question\"],\"status\":[\"reported\"]},\"requestedFields\":[],\"pageSize\":10,\"orderBy\":\"recentReportedOn\",\"orderDirection\":\"DESC\",\"facets\":[\"type\"]}\nfilter.criteria.mdo.report.answerPost.feed={\"filterCriteriaMap\":{\"type\":[\"answerPost\"],\"status\":[\"reported\"]},\"requestedFields\":[],\"pageSize\":10,\"orderBy\":\"recentReportedOn\",\"orderDirection\":\"DESC\",\"facets\":[\"type\"]}\nfilter.criteria.mdo.report.answerPostReply.feed={\"filterCriteriaMap\":{\"type\":[\"answerPostReply\"],\"status\":[\"reported\"]},\"requestedFields\":[],\"pageSize\":10,\"orderBy\":\"recentReportedOn\",\"orderDirection\":\"DESC\",\"facets\":[\"type\"]}\nfilter.criteria.mdo.all.suspended.feed={\"filterCriteriaMap\":{\"type\":[\"question\",\"answerPost\",\"answerPostReply\"],\"status\":[\"suspended\"]},\"requestedFields\":[],\"pageSize\":10,\"orderBy\":\"recentReportedOn\",\"orderDirection\":\"DESC\",\"facets\":[\"type\"]}\nfilter.criteria.question.document.feed={\"filterCriteriaMap\":{\"type\":\"question\",\"categoryType\":[\"document\"]},\"requestedFields\":[],\"pageSize\":10,\"orderBy\":\"createdOn\",\"orderDirection\":\"DESC\",\"facets\":[]}\nfilter.criteria.question.user.feed={\"filterCriteriaMap\":{\"type\":\"question\"},\"requestedFields\":[],\"pageSize\":10,\"orderBy\":\"createdOn\",\"orderDirection\":\"DESC\",\"facets\":[]}\nuser.feed.filter.criteriaMapSize=3\n\n\nnotification.api.url=http://cb-notification-wrapper-service:8081/notifications/create
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>ISO-8859-1
===================================================================
diff --git a/src/main/resources/application.properties b/src/main/resources/application.properties
--- a/src/main/resources/application.properties	(revision 6f4470fe2ef7499981fac434a4e27e1eb28f81fa)
+++ b/src/main/resources/application.properties	(date 1749403865492)
@@ -7,8 +7,8 @@
 
 #spring data jpa for postgres
 spring.datasource.url=jdbc:postgresql://localhost:5432/sunbird
-spring.datasource.username=
-spring.datasource.password=
+spring.datasource.username=postgres
+spring.datasource.password=password123
 spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect
 spring.jpa.properties.hibernate.format_sql=true
 spring.jpa.show-sql=false
@@ -55,7 +55,7 @@
 discussion.cloud.folder.name=discussionhub
 discussion.container.name=igot
 
-accesstoken.publickey.basepath=
+accesstoken.publickey.basepath=/home/deepikamalav/Downloads/p14XGYktp1RsRpFYyvFNvnzE1T0LOxUHph6xGK51tho
 kafka.topic.community.discusion.post.count.group=dev.community.discusion.post.count.group
 kafka.topic.community.discusion.post.count=dev.community.discusion.post.count
 kafka.topic.community.discusion.like.count.group=dev.community.discusion.like.count.group
@@ -90,4 +90,6 @@
 user.feed.filter.criteriaMapSize=3
 
 
-notification.api.url=http://cb-notification-wrapper-service:8081/notifications/create
\ No newline at end of file
+notification.api.url=http://cb-notification-wrapper-service:8081/notifications/create
+
+sb.api.key=bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJNNWVldkxVTUV6TTRmTUU0QUU0MUIzOTJmTzYzWVFwMSJ9.eP6JnGE69Q2KxrdtD0FVBK8gSZ37jK1HpyME7rJE8ZU
\ No newline at end of file
Index: src/main/java/com/igot/cb/discussion/service/impl/DiscussionServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.igot.cb.discussion.service.impl;\n\nimport com.auth0.jwt.JWT;\nimport com.auth0.jwt.algorithms.Algorithm;\nimport com.datastax.oss.driver.api.core.uuid.Uuids;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.ArrayNode;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.igot.cb.authentication.util.AccessTokenValidator;\nimport com.igot.cb.discussion.entity.CommunityEntity;\nimport com.igot.cb.discussion.entity.DiscussionAnswerPostReplyEntity;\nimport com.igot.cb.discussion.entity.DiscussionEntity;\nimport com.igot.cb.discussion.repository.CommunityEngagementRepository;\nimport com.igot.cb.discussion.repository.DiscussionAnswerPostReplyRepository;\nimport com.igot.cb.discussion.repository.DiscussionRepository;\nimport com.igot.cb.discussion.service.DiscussionService;\nimport com.igot.cb.metrics.service.ApiMetricsTracker;\nimport com.igot.cb.notificationUtill.HelperMethodService;\nimport com.igot.cb.notificationUtill.NotificationTriggerService;\nimport com.igot.cb.pores.cache.CacheService;\nimport com.igot.cb.pores.elasticsearch.dto.SearchCriteria;\nimport com.igot.cb.pores.elasticsearch.dto.SearchResult;\nimport com.igot.cb.pores.elasticsearch.service.EsUtilService;\nimport com.igot.cb.pores.util.*;\nimport com.igot.cb.producer.Producer;\nimport com.igot.cb.transactional.cassandrautils.CassandraOperation;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.collections.CollectionUtils;\nimport org.apache.commons.collections4.MapUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.multipart.MultipartFile;\nimport org.sunbird.cloud.storage.BaseStorageService;\nimport org.sunbird.cloud.storage.factory.StorageConfig;\nimport org.sunbird.cloud.storage.factory.StorageServiceFactory;\nimport scala.Option;\n\nimport javax.annotation.PostConstruct;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.time.Instant;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.sql.Timestamp;\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\nimport java.util.stream.StreamSupport;\n\nimport static com.igot.cb.pores.util.Constants.*;\n\n@Service\n@Slf4j\npublic class DiscussionServiceImpl implements DiscussionService {\n    private BaseStorageService storageService = null;\n\n    @Autowired\n    private PayloadValidation payloadValidation;\n    @Autowired\n    private DiscussionRepository discussionRepository;\n    @Autowired\n    private CacheService cacheService;\n    @Autowired\n    private EsUtilService esUtilService;\n    @Autowired\n    private CbServerProperties cbServerProperties;\n    @Autowired\n    @Qualifier(Constants.SEARCH_RESULT_REDIS_TEMPLATE)\n    private RedisTemplate<String, SearchResult> redisTemplate;\n    @Autowired\n    private ObjectMapper objectMapper;\n    @Autowired\n    private CassandraOperation cassandraOperation;\n    @Autowired\n    private AccessTokenValidator accessTokenValidator;\n    @Autowired\n    private CommunityEngagementRepository communityEngagementRepository;\n    @Autowired\n    private Producer producer;\n    @Autowired\n    private DiscussionAnswerPostReplyRepository discussionAnswerPostReplyRepository;\n    @Autowired\n    private NotificationTriggerService notificationTriggerService;\n    @Autowired\n    private HelperMethodService helperMethodService;\n\n\n    @PostConstruct\n    public void init() {\n        if (storageService == null) {\n            storageService = StorageServiceFactory.getStorageService(new StorageConfig(cbServerProperties.getCloudStorageTypeName(), cbServerProperties.getCloudStorageKey(), cbServerProperties.getCloudStorageSecret().replace(\"\\\\n\", \"\\n\"), Option.apply(cbServerProperties.getCloudStorageEndpoint()), Option.empty()));\n        }\n    }\n\n    /**\n     * Creates a new discussion based on the provided discussion details.\n     *\n     * @param discussionDetails The details of the discussion to be created.\n     * @return A CustomResponse object containing the result of the operation.\n     */\n    @Override\n    public ApiResponse createDiscussion(JsonNode discussionDetails, String token) {\n        log.info(\"DiscussionService::createDiscussion:creating discussion\");\n        ApiResponse response = ProjectUtil.createDefaultResponse(\"discussion.create\");\n        payloadValidation.validatePayload(Constants.DISCUSSION_VALIDATION_SCHEMA, discussionDetails);\n        String userId = accessTokenValidator.verifyUserToken(token);\n        if (StringUtils.isBlank(userId) || userId.equals(Constants.UNAUTHORIZED)) {\n            response.getParams().setErrMsg(Constants.INVALID_AUTH_TOKEN);\n            response.setResponseCode(HttpStatus.BAD_REQUEST);\n            return response;\n        }\n        if (!validateCommunityId(discussionDetails.get(Constants.COMMUNITY_ID).asText())) {\n            response.getParams().setErrMsg(Constants.INVALID_COMMUNITY_ID);\n            response.setResponseCode(HttpStatus.BAD_REQUEST);\n            return response;\n        }\n        updateMetricsApiCall(Constants.DISCUSSION_CREATE);\n        try {\n            ObjectNode discussionDetailsNode = (ObjectNode) discussionDetails;\n            Map<String, Object> propertyMap = new HashMap<>();\n            propertyMap.put(Constants.USERID, userId);\n            propertyMap.put(Constants.COMMUNITY_ID, discussionDetailsNode.get(Constants.COMMUNITY_ID).asText());\n            List<Map<String, Object>> communityDetails = cassandraOperation.getRecordsByPropertiesWithoutFiltering(Constants.KEYSPACE_SUNBIRD, Constants.USER_COMMUNITY, propertyMap, Arrays.asList(Constants.STATUS), null);\n            if (communityDetails.isEmpty() || !(boolean) communityDetails.get(0).get(Constants.STATUS)) {\n                DiscussionServiceUtil.createErrorResponse(response, Constants.USER_NOT_PART_OF_COMMUNITY, HttpStatus.BAD_REQUEST, Constants.FAILED);\n                return response;\n            }\n            discussionDetailsNode.put(Constants.CREATED_BY, userId);\n            discussionDetailsNode.put(Constants.UP_VOTE_COUNT, 0L);\n            discussionDetailsNode.put(Constants.STATUS, Constants.ACTIVE);\n\n            DiscussionEntity jsonNodeEntity = new DiscussionEntity();\n            Timestamp currentTime = new Timestamp(System.currentTimeMillis());\n\n            UUID id = Uuids.timeBased();\n            discussionDetailsNode.put(Constants.DISCUSSION_ID, String.valueOf(id));\n            jsonNodeEntity.setDiscussionId(String.valueOf(id));\n            jsonNodeEntity.setCreatedOn(currentTime);\n            discussionDetailsNode.put(Constants.CREATED_ON, getFormattedCurrentTime(currentTime));\n            discussionDetailsNode.put(Constants.UPDATED_ON, getFormattedCurrentTime(currentTime));\n            jsonNodeEntity.setUpdatedOn(currentTime);\n            jsonNodeEntity.setIsActive(true);\n            discussionDetailsNode.put(Constants.IS_ACTIVE, true);\n            jsonNodeEntity.setData(discussionDetailsNode);\n            long postgresTime = System.currentTimeMillis();\n            DiscussionEntity saveJsonEntity = discussionRepository.save(jsonNodeEntity);\n            updateMetricsDbOperation(Constants.DISCUSSION_CREATE, Constants.POSTGRES, Constants.INSERT, postgresTime);\n            ObjectNode jsonNode = objectMapper.createObjectNode();\n            jsonNode.setAll(discussionDetailsNode);\n            Map<String, Object> map = objectMapper.convertValue(discussionDetailsNode, Map.class);\n\n            response.setResponseCode(HttpStatus.CREATED);\n            response.getParams().setStatus(Constants.SUCCESS);\n            response.setResult(map);\n            esUtilService.addDocument(cbServerProperties.getDiscussionEntity(), saveJsonEntity.getDiscussionId(), map, cbServerProperties.getElasticDiscussionJsonPath());\n            cacheService.putCache(Constants.DISCUSSION_CACHE_PREFIX + saveJsonEntity.getDiscussionId(), jsonNode);\n            deleteCacheByCommunity(Constants.DISCUSSION_CACHE_PREFIX + discussionDetails.get(Constants.COMMUNITY_ID).asText());\n            deleteCacheByCommunity(Constants.DISCUSSION_POSTS_BY_USER + discussionDetails.get(Constants.COMMUNITY_ID).asText() + Constants.UNDER_SCORE + userId);\n            updateCacheForFirstFivePages(discussionDetails.get(Constants.COMMUNITY_ID).asText(), false);\n            updateCacheForGlobalFeed(userId);\n            log.info(\"Updated cache for global feed\");\n            Map<String, String> communityObject = new HashMap<>();\n            communityObject.put(Constants.COMMUNITY_ID, discussionDetails.get(Constants.COMMUNITY_ID).asText());\n            communityObject.put(Constants.STATUS, Constants.INCREMENT);\n            communityObject.put(Constants.TYPE, Constants.POST);\n            producer.push(cbServerProperties.getCommunityPostCount(), communityObject);\n        } catch (Exception e) {\n            log.error(\"Failed to create discussion: {}\", e.getMessage(), e);\n            DiscussionServiceUtil.createErrorResponse(response, Constants.FAILED_TO_CREATE_DISCUSSION, HttpStatus.INTERNAL_SERVER_ERROR, Constants.FAILED);\n            return response;\n        }\n        return response;\n    }\n\n    private void updateCacheForGlobalFeed(String userId) {\n        try {\n            ObjectMapper objectMapper = new ObjectMapper();\n            SearchCriteria searchCriteria = objectMapper.readValue(cbServerProperties.getFilterCriteriaForGlobalFeed(), SearchCriteria.class);\n            getGlobalFeedUsingUserId(searchCriteria, userId, true);\n        } catch (Exception e) {\n            log.error(\"Error occured while updating the cache for globalFeed\", e);\n            throw new RuntimeException(\"Error parsing filter criteria JSON\", e);\n        }\n    }\n\n    /**\n     * Returns the discussion with the given id.\n     *\n     * @param discussionId The id of the discussion to retrieve\n     * @return A CustomResponse containing the discussion's details\n     */\n    @Override\n    public ApiResponse readDiscussion(String discussionId) {\n        log.info(\"reading discussion details\");\n        ApiResponse response = ProjectUtil.createDefaultResponse(\"discussion.read\");\n        if (StringUtils.isEmpty(discussionId)) {\n            log.error(\"discussion not found\");\n            DiscussionServiceUtil.createErrorResponse(response, Constants.ID_NOT_FOUND, HttpStatus.BAD_REQUEST, Constants.FAILED);\n            return response;\n        }\n        try {\n            updateMetricsApiCall(Constants.DISCUSSION_READ);\n            long redisTime = System.currentTimeMillis();\n            String cachedJson = cacheService.getCache(Constants.DISCUSSION_CACHE_PREFIX + discussionId);\n            updateMetricsDbOperation(Constants.DISCUSSION_READ, Constants.REDIS, Constants.READ, redisTime);\n            if (StringUtils.isNotEmpty(cachedJson)) {\n                log.info(\"discussion Record coming from redis cache\");\n                response.setMessage(Constants.SUCCESS);\n                response.setResponseCode(HttpStatus.OK);\n                response.setResult((Map<String, Object>) objectMapper.readValue(cachedJson, new TypeReference<Object>() {\n                }));\n            } else {\n                long postgresTime = System.currentTimeMillis();\n                Optional<DiscussionEntity> entityOptional = discussionRepository.findById(discussionId);\n                updateMetricsDbOperation(Constants.DISCUSSION_READ, Constants.POSTGRES, Constants.READ, postgresTime);\n                if (entityOptional.isPresent()) {\n                    DiscussionEntity discussionEntity = entityOptional.get();\n                    cacheService.putCache(Constants.DISCUSSION_CACHE_PREFIX + discussionId, discussionEntity.getData());\n                    log.info(\"discussion Record coming from postgres db\");\n                    response.setMessage(Constants.SUCCESS);\n                    response.setResponseCode(HttpStatus.OK);\n                    response.setResult((Map<String, Object>) objectMapper.convertValue(discussionEntity.getData(), new TypeReference<Object>() {\n                    }));\n                    response.getResult().put(Constants.IS_ACTIVE, discussionEntity.getIsActive());\n                    response.getResult().put(Constants.CREATED_ON, discussionEntity.getCreatedOn());\n                } else {\n                    log.error(\"Invalid discussionId: {}\", discussionId);\n                    DiscussionServiceUtil.createErrorResponse(response, Constants.INVALID_ID, HttpStatus.NOT_FOUND, Constants.FAILED);\n                    return response;\n                }\n            }\n        } catch (Exception e) {\n            log.error(\" JSON for discussionId {}: {}\", discussionId, e.getMessage(), e);\n            DiscussionServiceUtil.createErrorResponse(response, \"Failed to read the discussion\", HttpStatus.INTERNAL_SERVER_ERROR, Constants.FAILED);\n            return response;\n        }\n        return response;\n    }\n\n\n    /**\n     * Updates the discussion with the given id based on the provided update data.\n     *\n     * @param updateData The data to be used for the update operation.\n     * @return A CustomResponse object containing the result of the operation.\n     */\n    @Override\n    public ApiResponse updateDiscussion(JsonNode updateData, String token) {\n        ApiMetricsTracker.enableTracking();\n        ApiResponse response = ProjectUtil.createDefaultResponse(\"update.Discussion\");\n        payloadValidation.validatePayload(Constants.DISCUSSION_UPDATE_VALIDATION_SCHEMA, updateData);\n        String userId = accessTokenValidator.verifyUserToken(token);\n        if (StringUtils.isBlank(userId) || Constants.UNAUTHORIZED.equals(userId)) {\n            response.getParams().setErrMsg(Constants.INVALID_AUTH_TOKEN);\n            response.setResponseCode(HttpStatus.BAD_REQUEST);\n            return response;\n        }\n        try {\n            updateMetricsApiCall(Constants.DISCUSSION_UPDATE);\n            String discussionId = updateData.get(Constants.DISCUSSION_ID).asText();\n            long postgresTime = System.currentTimeMillis();\n            Optional<DiscussionEntity> discussionEntity = discussionRepository.findById(discussionId);\n            updateMetricsDbOperation(Constants.DISCUSSION_UPDATE, Constants.POSTGRES, Constants.READ, postgresTime);\n            if (!discussionEntity.isPresent()) {\n                DiscussionServiceUtil.createErrorResponse(response, \"Discussion not found\", HttpStatus.NOT_FOUND, Constants.FAILED);\n                return response;\n            }\n            DiscussionEntity discussionDbData = discussionEntity.get();\n            if (!discussionDbData.getIsActive()) {\n                DiscussionServiceUtil.createErrorResponse(response, Constants.DISCUSSION_IS_NOT_ACTIVE, HttpStatus.BAD_REQUEST, Constants.FAILED);\n                return response;\n            }\n            ObjectNode data = (ObjectNode) discussionDbData.getData();\n            ObjectNode updateDataNode = (ObjectNode) updateData;\n            if (data.get(Constants.COMMUNITY_ID) != null && !data.get(Constants.COMMUNITY_ID).asText().equals(updateDataNode.get(Constants.COMMUNITY_ID).asText())) {\n                DiscussionServiceUtil.createErrorResponse(response, Constants.COMMUNITY_ID_CANNOT_BE_UPDATED, HttpStatus.BAD_REQUEST, Constants.FAILED);\n                return response;\n            }\n            String communityId = updateData.get(Constants.COMMUNITY_ID).asText();\n            updateDataNode.remove(Constants.COMMUNITY_ID);\n            updateDataNode.remove(Constants.DISCUSSION_ID);\n            data.setAll(updateDataNode);\n\n            if (!updateData.has(Constants.IS_INITIAL_UPLOAD) || !updateData.get(Constants.IS_INITIAL_UPLOAD).asBoolean()) {\n                Timestamp currentTime = new Timestamp(System.currentTimeMillis());\n                data.put(Constants.UPDATED_ON, getFormattedCurrentTime(currentTime));\n                discussionDbData.setUpdatedOn(currentTime);\n            }\n\n            discussionDbData.setData(data);\n            long postgresInsertTime = System.currentTimeMillis();\n            discussionRepository.save(discussionDbData);\n            updateMetricsDbOperation(Constants.DISCUSSION_CREATE, Constants.POSTGRES, Constants.UPDATE_KEY, postgresInsertTime);\n            ObjectNode jsonNode = objectMapper.createObjectNode();\n            jsonNode.setAll(data);\n\n            Map<String, Object> map = objectMapper.convertValue(jsonNode, Map.class);\n            esUtilService.updateDocument(cbServerProperties.getDiscussionEntity(), discussionDbData.getDiscussionId(), map, cbServerProperties.getElasticDiscussionJsonPath());\n            cacheService.putCache(Constants.DISCUSSION_CACHE_PREFIX + discussionDbData.getDiscussionId(), jsonNode);\n            deleteCacheByCommunity(Constants.DISCUSSION_POSTS_BY_USER + data.get(Constants.COMMUNITY_ID).asText() + Constants.UNDER_SCORE + userId);\n            if (data.has(Constants.CATEGORY_TYPE)\n                    && data.get(Constants.CATEGORY_TYPE).isArray()\n                    && StreamSupport.stream(data.get(Constants.CATEGORY_TYPE).spliterator(), false)\n                    .anyMatch(node -> Constants.DOCUMENT.equals(node.asText()))) {\n                deleteCacheByCommunity(Constants.DISCUSSION_DOCUMENT_POST + data.get(Constants.COMMUNITY_ID).asText());\n                updateCacheForFirstFivePages(communityId, true);\n            }\n            Map<String, Object> responseMap = objectMapper.convertValue(discussionDbData, new TypeReference<Map<String, Object>>() {\n            });\n            response.setResponseCode(HttpStatus.OK);\n            response.setResult(responseMap);\n            response.getParams().setStatus(Constants.SUCCESS);\n            deleteCacheByCommunity(Constants.DISCUSSION_CACHE_PREFIX + communityId);\n            updateCacheForFirstFivePages(communityId, false);\n            updateCacheForGlobalFeed(userId);\n            log.info(\"Updated cache for global feed\");\n        } catch (Exception e) {\n            log.error(\"Failed to update the discussion: \", e);\n            DiscussionServiceUtil.createErrorResponse(response, \"Failed to update the discussion\", HttpStatus.INTERNAL_SERVER_ERROR, Constants.FAILED);\n            return response;\n        }\n        return response;\n    }\n\n\n    @Override\n    public ApiResponse searchDiscussion(SearchCriteria searchCriteria, boolean isOverride) {\n        log.info(\"DiscussionServiceImpl::searchDiscussion\");\n        ApiMetricsTracker.enableTracking();\n        ApiResponse response = ProjectUtil.createDefaultResponse(\"search.discussion\");\n        boolean isTrending = isTrendingPost(searchCriteria);\n        String cacheKey = generateRedisTokenKey(searchCriteria);\n        SearchResult searchResult = null;\n        if (!isOverride) {\n            searchResult = redisTemplate.opsForValue().get(cacheKey);\n        }\n\n        if (searchResult != null) {\n            log.info(\"DiscussionServiceImpl::searchDiscussion:  search result fetched from redis\");\n            response.getResult().put(Constants.SEARCH_RESULTS, searchResult);\n            DiscussionServiceUtil.createSuccessResponse(response);\n            return response;\n        }\n        String searchString = searchCriteria.getSearchString();\n        if (searchString != null && !searchString.isEmpty() && searchString.length() < 3) {\n            DiscussionServiceUtil.createErrorResponse(response, Constants.MINIMUM_CHARACTERS_NEEDED, HttpStatus.BAD_REQUEST, Constants.FAILED_CONST);\n            return response;\n        }\n        try {\n            log.info(\"DiscussionServiceImpl::searchDiscussion:  search result fetched from es\");\n            if (MapUtils.isEmpty(searchCriteria.getFilterCriteriaMap())) {\n                searchCriteria.setFilterCriteriaMap(new HashMap<>());\n            }\n            searchCriteria.getFilterCriteriaMap().put(Constants.IS_ACTIVE, true);\n\n            if (!searchCriteria.getFilterCriteriaMap().containsKey(Constants.STATUS) ||\n                    (!searchCriteria.getFilterCriteriaMap().get(Constants.STATUS).equals(Collections.singletonList(Constants.REPORTED)) &&\n                            !searchCriteria.getFilterCriteriaMap().get(Constants.STATUS).equals(Collections.singletonList(Constants.SUSPENDED)))) {\n                searchCriteria.getFilterCriteriaMap().put(Constants.STATUS, Arrays.asList(Constants.ACTIVE, Constants.REPORTED));\n            }\n\n            if (isTrending) {\n                List<String> communityIds = getTrendingPosts();\n                searchCriteria.getFilterCriteriaMap().put(Constants.COMMUNITY_ID, communityIds);\n            }\n            searchResult = esUtilService.searchDocuments(cbServerProperties.getDiscussionEntity(), searchCriteria, cbServerProperties.getElasticDiscussionJsonPath());\n            if (CollectionUtils.isEmpty(searchResult.getData())) {\n                DiscussionServiceUtil.createErrorResponse(response, Constants.NO_DATA_FOUND, HttpStatus.OK, Constants.SUCCESS);\n                response.getResult().put(Constants.SEARCH_RESULTS, searchResult);\n                return response;\n            }\n            List<Map<String, Object>> discussions = searchResult.getData();\n\n            if (searchCriteria.getRequestedFields().contains(Constants.CREATED_BY) || searchCriteria.getRequestedFields().isEmpty()) {\n                boolean isAnswerPost = false;\n                if (searchCriteria.getFilterCriteriaMap().containsKey(Constants.TYPE) && Constants.ANSWER_POST.equals(searchCriteria.getFilterCriteriaMap().get(Constants.TYPE))) {\n                    isAnswerPost = true;\n                }\n                fetchAndEnhanceDiscussions(discussions, isAnswerPost);\n            }\n            if (isTrending) {\n                enhanceCommunityData(discussions);\n            }\n            searchResult.setData(discussions);\n            redisTemplate.opsForValue().set(cacheKey, searchResult, cbServerProperties.getSearchResultRedisTtl(), TimeUnit.SECONDS);\n            response.getResult().put(Constants.SEARCH_RESULTS, searchResult);\n            DiscussionServiceUtil.createSuccessResponse(response);\n            return response;\n        } catch (Exception e) {\n            log.error(\"error while searching discussion : {} .\", e.getMessage(), e);\n            DiscussionServiceUtil.createErrorResponse(response, e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR, Constants.FAILED_CONST);\n            return response;\n        }\n    }\n\n    /**\n     * Deletes the discussion with the given id.\n     *\n     * @param discussionId The id of the discussion to be deleted.\n     * @return A CustomResponse object containing the result of the operation.\n     */\n    @Override\n    public ApiResponse deleteDiscussion(String discussionId, String type, String token) {\n        log.info(\"DiscussionServiceImpl::delete Discussion\");\n        ApiResponse response = ProjectUtil.createDefaultResponse(\"delete.discussion\");\n        try {\n            String userId = accessTokenValidator.verifyUserToken(token);\n            if (StringUtils.isBlank(userId)) {\n                response.getParams().setErrMsg(Constants.INVALID_AUTH_TOKEN);\n                response.setResponseCode(HttpStatus.BAD_REQUEST);\n                return response;\n            }\n\n            if (StringUtils.isNotEmpty(discussionId)) {\n                Optional<DiscussionEntity> entityOptional = discussionRepository.findById(discussionId);\n                if (entityOptional.isPresent()) {\n                    DiscussionEntity jasonEntity = entityOptional.get();\n                    JsonNode data = jasonEntity.getData();\n                    if (!type.equals(data.get(Constants.TYPE).asText())) {\n                        DiscussionServiceUtil.createErrorResponse(response, Constants.INVALID_TYPE + type, HttpStatus.BAD_REQUEST, Constants.FAILED);\n                        return response;\n                    }\n                    Timestamp currentTime = new Timestamp(System.currentTimeMillis());\n                    if (jasonEntity.getIsActive()) {\n                        jasonEntity.setIsActive(false);\n                        jasonEntity.setUpdatedOn(currentTime);\n                        ((ObjectNode) data).put(Constants.IS_ACTIVE, false);\n                        ((ObjectNode) data).put(Constants.UPDATED_ON, String.valueOf(currentTime));\n                        jasonEntity.setData(data);\n                        jasonEntity.setDiscussionId(discussionId);\n                        jasonEntity.setUpdatedOn(currentTime);\n                        discussionRepository.save(jasonEntity);\n                        Map<String, Object> map = objectMapper.convertValue(data, Map.class);\n                        map.put(Constants.IS_ACTIVE, false);\n                        esUtilService.updateDocument(cbServerProperties.getDiscussionEntity(), discussionId, map, cbServerProperties.getElasticDiscussionJsonPath());\n                        cacheService.putCache(Constants.DISCUSSION_CACHE_PREFIX + discussionId, data);\n                        log.info(\"Discussion details deleted successfully\");\n                        response.setResponseCode(HttpStatus.OK);\n                        response.setMessage(Constants.DELETED_SUCCESSFULLY);\n                        response.getParams().setStatus(Constants.SUCCESS);\n                        Map<String, String> communityObject = new HashMap<>();\n                        communityObject.put(Constants.COMMUNITY_ID,\n                                (String) map.get(Constants.COMMUNITY_ID));\n                        communityObject.put(Constants.STATUS, Constants.DECREMENT);\n                        if (Constants.QUESTION.equalsIgnoreCase(data.get(Constants.TYPE).asText())) {\n                            communityObject.put(Constants.TYPE, Constants.POST);\n                        } else {\n                            communityObject.put(Constants.TYPE, Constants.ANSWER_POST);\n                            DiscussionEntity discussionEntity = discussionRepository.findById(\n                                    data.get(Constants.PARENT_DISCUSSION_ID).asText()).orElse(null);\n                            if (discussionEntity != null) {\n                                updateAnswerPostToDiscussion(discussionEntity, discussionId,\n                                        Constants.DECREMENT);\n                            }\n                            redisTemplate.opsForValue().getAndDelete(\n                                    DiscussionServiceUtil.generateRedisJwtTokenKey(createSearchCriteriaWithDefaults(\n                                            data.get(Constants.PARENT_DISCUSSION_ID).asText(),\n                                            data.get(Constants.COMMUNITY_ID).asText(),\n                                            Constants.ANSWER_POST)));\n                        }\n                        deleteCacheByCommunity(Constants.DISCUSSION_CACHE_PREFIX + map.get(Constants.COMMUNITY_ID));\n                        updateCacheForFirstFivePages((String) map.get(Constants.COMMUNITY_ID), false);\n                        updateCacheForGlobalFeed(userId);\n                        log.info(\"Updated cache for global feed\");\n                        producer.push(cbServerProperties.getCommunityPostCount(), communityObject);\n                        return response;\n                    } else {\n                        log.info(\"Discussion is already inactive.\");\n                        DiscussionServiceUtil.createErrorResponse(response, Constants.DISCUSSION_IS_INACTIVE, HttpStatus.ALREADY_REPORTED, Constants.SUCCESS);\n                        return response;\n                    }\n                } else {\n                    DiscussionServiceUtil.createErrorResponse(response, Constants.INVALID_ID, HttpStatus.BAD_REQUEST, Constants.NO_DATA_FOUND);\n                    return response;\n                }\n            }\n        } catch (Exception e) {\n            log.error(\"Error while deleting discussion with ID: {}. Exception: {}\", discussionId, e.getMessage(), e);\n            DiscussionServiceUtil.createErrorResponse(response, Constants.FAILED_TO_DELETE_DISCUSSION, HttpStatus.INTERNAL_SERVER_ERROR, Constants.FAILED);\n            return response;\n        }\n        return response;\n    }\n\n    private ApiResponse vote(String discussionId, String type, String token, String voteType) {\n        log.info(\"DiscussionServiceImpl::vote - Type: {}\", voteType);\n        ApiResponse response = ProjectUtil.createDefaultResponse(Constants.DISCUSSION_VOTE_API);\n        try {\n            String userId = accessTokenValidator.verifyUserToken(token);\n            if (StringUtils.isEmpty(userId) || Constants.UNAUTHORIZED.equals(userId)) {\n                DiscussionServiceUtil.createErrorResponse(response, Constants.INVALID_AUTH_TOKEN, HttpStatus.BAD_REQUEST, Constants.FAILED);\n                return response;\n            }\n\n            boolean isAnswerReply = Constants.ANSWER_POST_REPLY.equals(type);\n            Object entityObject = isAnswerReply\n                    ? discussionAnswerPostReplyRepository.findById(discussionId).orElse(null)\n                    : discussionRepository.findById(discussionId).orElse(null);\n\n            if (entityObject == null) {\n                DiscussionServiceUtil.createErrorResponse(response, Constants.DISCUSSION_NOT_FOUND, HttpStatus.BAD_REQUEST, Constants.FAILED);\n                return response;\n            }\n\n            JsonNode dataNode;\n            Boolean isActive;\n            if (isAnswerReply) {\n                DiscussionAnswerPostReplyEntity replyEntity = (DiscussionAnswerPostReplyEntity) entityObject;\n                dataNode = replyEntity.getData();\n                isActive = replyEntity.getIsActive();\n            } else {\n                DiscussionEntity discussionEntity = (DiscussionEntity) entityObject;\n                dataNode = discussionEntity.getData();\n                isActive = discussionEntity.getIsActive();\n            }\n\n            HashMap<String, Object> discussionData = objectMapper.convertValue(dataNode, HashMap.class);\n\n            if (!isActive) {\n                DiscussionServiceUtil.createErrorResponse(response, Constants.DISCUSSION_IS_INACTIVE, HttpStatus.BAD_REQUEST, Constants.FAILED);\n                return response;\n            }\n            if (!type.equals(discussionData.get(Constants.TYPE))) {\n                DiscussionServiceUtil.createErrorResponse(response, Constants.INVALID_TYPE + type, HttpStatus.BAD_REQUEST, Constants.FAILED);\n                return response;\n            }\n\n            boolean currentVote = Constants.UP.equals(voteType);\n\n            Object upVoteCountObj = discussionData.get(Constants.UP_VOTE_COUNT);\n            long existingUpVoteCount = (upVoteCountObj instanceof Number) ? ((Number) upVoteCountObj).longValue() : 0L;\n\n            Map<String, Object> properties = new HashMap<>();\n            properties.put(Constants.DISCUSSION_ID_KEY, discussionId);\n            properties.put(Constants.USERID, userId);\n            List<Map<String, Object>> existingResponseList = cassandraOperation.getRecordsByPropertiesWithoutFiltering(Constants.KEYSPACE_SUNBIRD, Constants.USER_POST_VOTES, properties, null, null);\n\n            if (CollectionUtils.isEmpty(existingResponseList)) {\n                if (currentVote) {\n                    Map<String, Object> propertyMap = new HashMap<>();\n                    propertyMap.put(Constants.USER_ID_RQST, userId);\n                    propertyMap.put(Constants.DISCUSSION_ID_KEY, discussionId);\n                    propertyMap.put(Constants.VOTE_TYPE, currentVote);\n\n                    ApiResponse result = (ApiResponse) cassandraOperation.insertRecord(Constants.KEYSPACE_SUNBIRD, Constants.USER_POST_VOTES, propertyMap);\n                    Map<String, Object> resultMap = result.getResult();\n                    if (!resultMap.get(Constants.RESPONSE).equals(Constants.SUCCESS)) {\n                        response.setResponseCode(HttpStatus.INTERNAL_SERVER_ERROR);\n                        response.setMessage(Constants.FAILED);\n                        return response;\n                    }\n                    Map<String, String> communityObject = new HashMap<>();\n                    communityObject.put(Constants.COMMUNITY_ID, dataNode.get(Constants.COMMUNITY_ID).asText());\n                    communityObject.put(Constants.STATUS, Constants.INCREMENT);\n                    communityObject.put(Constants.DISCUSSION_ID, discussionId);\n                    producer.push(cbServerProperties.getCommunityLikeCount(), communityObject);\n                } else {\n                    DiscussionServiceUtil.createErrorResponse(response, Constants.USER_MUST_VOTE_FIRST, HttpStatus.BAD_REQUEST, Constants.FAILED);\n                    return response;\n                }\n            } else {\n                Map<String, Object> userVoteData = existingResponseList.get(0);\n                if (userVoteData.get(Constants.VOTE_TYPE).equals(currentVote)) {\n                    DiscussionServiceUtil.createErrorResponse(response, String.format(Constants.USER_ALREADY_VOTED, voteType), HttpStatus.ALREADY_REPORTED, Constants.FAILED);\n                    return response;\n                }\n\n                Map<String, Object> updateAttribute = new HashMap<>();\n                updateAttribute.put(Constants.VOTE_TYPE, currentVote);\n                Map<String, Object> compositeKeys = new HashMap<>();\n                compositeKeys.put(Constants.USER_ID_RQST, userId);\n                compositeKeys.put(Constants.DISCUSSION_ID_KEY, discussionId);\n\n                Map<String, Object> result = cassandraOperation.updateRecordByCompositeKey(Constants.KEYSPACE_SUNBIRD, Constants.USER_POST_VOTES, updateAttribute, compositeKeys);\n                if (!result.get(Constants.RESPONSE).equals(Constants.SUCCESS)) {\n                    DiscussionServiceUtil.createErrorResponse(response, Constants.FAILED_TO_VOTE, HttpStatus.INTERNAL_SERVER_ERROR, Constants.FAILED);\n                    return response;\n                }\n\n                Map<String, String> communityObject = new HashMap<>();\n                communityObject.put(Constants.COMMUNITY_ID, dataNode.get(Constants.COMMUNITY_ID).asText());\n                communityObject.put(Constants.DISCUSSION_ID, discussionId);\n                communityObject.put(Constants.STATUS, Constants.UP.equals(voteType) ? Constants.INCREMENT : Constants.DECREMENT);\n                producer.push(cbServerProperties.getCommunityLikeCount(), communityObject);\n            }\n\n            discussionData.put(Constants.UP_VOTE_COUNT, currentVote ? existingUpVoteCount + 1 : existingUpVoteCount - 1);\n\n            JsonNode updatedData = objectMapper.valueToTree(discussionData);\n            if (isAnswerReply) {\n                DiscussionAnswerPostReplyEntity replyEntity = (DiscussionAnswerPostReplyEntity) entityObject;\n                replyEntity.setData(updatedData);\n                discussionAnswerPostReplyRepository.save(replyEntity);\n            } else {\n                DiscussionEntity discussionEntity = (DiscussionEntity) entityObject;\n                discussionEntity.setData(updatedData);\n                discussionRepository.save(discussionEntity);\n            }\n\n            esUtilService.updateDocument(cbServerProperties.getDiscussionEntity(), discussionId, discussionData, cbServerProperties.getElasticDiscussionJsonPath());\n            cacheService.putCache(Constants.DISCUSSION_CACHE_PREFIX + discussionId, discussionData);\n\n            if (!isAnswerReply) {\n                updateCacheForFirstFivePages(dataNode.get(Constants.COMMUNITY_ID).asText(), false);\n                updateCacheForGlobalFeed(userId);\n            }\n\n            String createdBy = dataNode.get(Constants.CREATED_BY).asText();\n\n            Map<String, Object> data = Map.of(\n                    Constants.COMMUNITY_ID, dataNode.get(Constants.COMMUNITY_ID).asText(),\n                    Constants.DISCUSSION_ID, discussionId\n            );\n\n            String firstName = helperMethodService.fetchUserFirstName(createdBy);\n\n            if (!userId.equals(createdBy)) {\n                if (type.equalsIgnoreCase(Constants.QUESTION)) {\n                    notificationTriggerService.triggerNotification(LIKED_POST, List.of(createdBy), TITLE, firstName, data);\n                } else if (type.equalsIgnoreCase(Constants.ANSWER_POST)) {\n                    notificationTriggerService.triggerNotification(LIKED_COMMENT, List.of(createdBy), TITLE, firstName, data);\n                } else if (type.equalsIgnoreCase(Constants.ANSWER_POST_REPLY)) {\n                    notificationTriggerService.triggerNotification(REPLIED_POST, List.of(createdBy), TITLE, firstName, data);\n                }\n            }\n\n            if (Constants.ANSWER_POST.equals(type)) {\n                redisTemplate.opsForValue()\n                        .getAndDelete(DiscussionServiceUtil.generateRedisJwtTokenKey(createSearchCriteriaWithDefaults(\n                                (String) discussionData.get(Constants.PARENT_DISCUSSION_ID),\n                                (String) discussionData.get(Constants.COMMUNITY_ID),\n                                Constants.ANSWER_POST)));\n            }\n            if (Constants.ANSWER_POST_REPLY.equals(type)) {\n                redisTemplate.opsForValue().getAndDelete(DiscussionServiceUtil.generateRedisJwtTokenKey(createDefaultSearchCriteria(\n                        (String) discussionData.get(Constants.PARENT_ANSWER_POST_ID),\n                        (String) discussionData.get(Constants.COMMUNITY_ID))));\n            }\n            response.setResponseCode(HttpStatus.OK);\n            response.getParams().setStatus(Constants.SUCCESS);\n        } catch (Exception e) {\n            log.error(\"Error while processing vote: {}\", e.getMessage(), e);\n            response.setResponseCode(HttpStatus.INTERNAL_SERVER_ERROR);\n            response.setMessage(Constants.FAILED);\n            response.getParams().setErrMsg(Constants.FAILED);\n            return response;\n        }\n        return response;\n    }\n\n    public List<Object> fetchDataForKeys(List<String> keys, boolean isUserData) {\n        // Fetch values for all keys from Redis\n        List<Object> values;\n        if (isUserData) {\n            values = cacheService.hget(keys);\n        } else {\n            values = cacheService.hgetMulti(keys);\n        }\n\n        // Create a map of key-value pairs, converting stringified JSON objects to User objects\n        return keys.stream()\n                .filter(key -> values.get(keys.indexOf(key)) != null) // Filter out null values\n                .map(key -> {\n                    String stringifiedJson = (String) values.get(keys.indexOf(key)); // Cast the value to String\n                    try {\n                        // Convert the stringified JSON to a User object using ObjectMapper\n                        return objectMapper.readValue(stringifiedJson, Object.class); // You can map this to a specific User type if needed\n                    } catch (Exception e) {\n                        log.error(\"Failed to fetch user data from redis \", e.getMessage(), e);\n                        return null; // Return null in case of error\n                    }\n                })\n                .collect(Collectors.toList());\n    }\n\n    public List<Object> fetchUserFromPrimary(List<String> userIds) {\n        log.info(\"DiscussionServiceImpl::fetchUserFromPrimary: Fetching user data from Cassandra\");\n        List<Object> userList = new ArrayList<>();\n        Map<String, Object> propertyMap = new HashMap<>();\n        propertyMap.put(Constants.ID, userIds);\n        long startTime = System.currentTimeMillis();\n        List<Map<String, Object>> userInfoList = cassandraOperation.getRecordsByPropertiesWithoutFiltering(\n                Constants.KEYSPACE_SUNBIRD, Constants.USER_TABLE, propertyMap,\n                Arrays.asList(Constants.PROFILE_DETAILS, Constants.FIRST_NAME, Constants.ID), null);\n        updateMetricsDbOperation(Constants.DISCUSSION_SEARCH, Constants.CASSANDRA, Constants.READ, startTime);\n        userList = userInfoList.stream()\n                .map(userInfo -> {\n                    Map<String, Object> userMap = new HashMap<>();\n\n                    // Extract user ID and user name\n                    String userId = (String) userInfo.get(Constants.ID);\n                    String userName = (String) userInfo.get(Constants.FIRST_NAME);\n\n                    userMap.put(Constants.USER_ID_KEY, userId);\n                    userMap.put(Constants.FIRST_NAME_KEY, userName);\n\n                    // Process profile details if present\n                    String profileDetails = (String) userInfo.get(Constants.PROFILE_DETAILS);\n                    if (StringUtils.isNotBlank(profileDetails)) {\n                        try {\n                            // Convert JSON profile details to a Map\n                            Map<String, Object> profileDetailsMap = objectMapper.readValue(profileDetails,\n                                    new TypeReference<HashMap<String, Object>>() {\n                                    });\n\n                            // Check for profile image and add to userMap if available\n                            if (MapUtils.isNotEmpty(profileDetailsMap)) {\n                                if (profileDetailsMap.containsKey(Constants.PROFILE_IMG) && StringUtils.isNotBlank((String) profileDetailsMap.get(Constants.PROFILE_IMG))) {\n                                    userMap.put(Constants.PROFILE_IMG_KEY, (String) profileDetailsMap.get(Constants.PROFILE_IMG));\n                                }\n                                if (profileDetailsMap.containsKey(Constants.DESIGNATION_KEY) && StringUtils.isNotEmpty((String) profileDetailsMap.get(Constants.DESIGNATION_KEY))) {\n\n                                    userMap.put(Constants.DESIGNATION_KEY, (String) profileDetailsMap.get(Constants.PROFILE_IMG));\n                                }\n                                if (profileDetailsMap.containsKey(Constants.EMPLOYMENT_DETAILS) && MapUtils.isNotEmpty(\n                                        (Map<?, ?>) profileDetailsMap.get(Constants.EMPLOYMENT_DETAILS)) && ((Map<?, ?>) profileDetailsMap.get(Constants.EMPLOYMENT_DETAILS)).containsKey(Constants.DEPARTMENT_KEY) && StringUtils.isNotBlank(\n                                        (String) ((Map<?, ?>) profileDetailsMap.get(Constants.EMPLOYMENT_DETAILS)).get(Constants.DEPARTMENT_KEY))) {\n                                    userMap.put(Constants.DEPARTMENT, (String) ((Map<?, ?>) profileDetailsMap.get(Constants.EMPLOYMENT_DETAILS)).get(Constants.DEPARTMENT_KEY));\n\n                                }\n                            }\n                        } catch (JsonProcessingException e) {\n                            log.error(\"Error occurred while converting json object to json string\", e);\n                        }\n                    }\n\n                    return userMap;\n                })\n                .collect(Collectors.toList());\n        return userList;\n    }\n\n    @Override\n    public ApiResponse createAnswerPost(JsonNode answerPostData, String token) {\n        log.info(\"DiscussionService::createAnswerPost:creating answerPost\");\n        ApiResponse response = ProjectUtil.createDefaultResponse(\"discussion.createAnswerPost\");\n        payloadValidation.validatePayload(Constants.DISCUSSION_ANSWER_POST_VALIDATION_SCHEMA, answerPostData);\n        String userId = accessTokenValidator.verifyUserToken(token);\n        if (StringUtils.isBlank(userId) || userId.equals(Constants.UNAUTHORIZED)) {\n            response.getParams().setErrMsg(Constants.INVALID_AUTH_TOKEN);\n            response.setResponseCode(HttpStatus.BAD_REQUEST);\n            return response;\n        }\n        updateMetricsApiCall(Constants.DISCUSSION_ANSWER_POST);\n        long postgresTime = System.currentTimeMillis();\n        DiscussionEntity discussionEntity = discussionRepository.findById(answerPostData.get(Constants.PARENT_DISCUSSION_ID).asText()).orElse(null);\n        updateMetricsDbOperation(Constants.DISCUSSION_ANSWER_POST, Constants.POSTGRES, Constants.READ, postgresTime);\n        if (discussionEntity == null || !discussionEntity.getIsActive()) {\n            return ProjectUtil.returnErrorMsg(Constants.INVALID_PARENT_DISCUSSION_ID, HttpStatus.BAD_REQUEST, response, Constants.FAILED);\n        }\n        JsonNode data = discussionEntity.getData();\n        String type = data.get(Constants.TYPE).asText();\n        if (type.equals(Constants.ANSWER_POST)) {\n            return ProjectUtil.returnErrorMsg(Constants.PARENT_ANSWER_POST_ID_ERROR, HttpStatus.BAD_REQUEST, response, Constants.FAILED);\n        }\n        if (data.get(Constants.STATUS).asText().equals(Constants.SUSPENDED)) {\n            return ProjectUtil.returnErrorMsg(Constants.PARENT_DISCUSSION_ID_ERROR, HttpStatus.BAD_REQUEST, response, Constants.FAILED);\n        }\n        if (!answerPostData.get(Constants.COMMUNITY_ID).asText().equals(data.get(Constants.COMMUNITY_ID).asText())) {\n            response.getParams().setErrMsg(Constants.INVALID_COMMUNITY_ID);\n            response.setResponseCode(HttpStatus.BAD_REQUEST);\n            return response;\n        }\n\n        try {\n            ObjectNode answerPostDataNode = (ObjectNode) answerPostData;\n            Map<String, Object> propertyMap = new HashMap<>();\n            propertyMap.put(Constants.USERID, userId);\n            propertyMap.put(Constants.COMMUNITY_ID, answerPostDataNode.get(Constants.COMMUNITY_ID).asText());\n            List<Map<String, Object>> communityDetails = cassandraOperation.getRecordsByPropertiesWithoutFiltering(Constants.KEYSPACE_SUNBIRD, Constants.USER_COMMUNITY, propertyMap, Arrays.asList(Constants.STATUS), null);\n            if (communityDetails.isEmpty() || !(boolean) communityDetails.get(0).get(Constants.STATUS)) {\n                DiscussionServiceUtil.createErrorResponse(response, Constants.USER_NOT_PART_OF_COMMUNITY, HttpStatus.BAD_REQUEST, Constants.FAILED);\n                return response;\n            }\n            answerPostDataNode.put(Constants.CREATED_BY, userId);\n            answerPostDataNode.put(Constants.VOTE_COUNT, 0);\n            answerPostDataNode.put(Constants.STATUS, Constants.ACTIVE);\n            answerPostDataNode.put(Constants.PARENT_DISCUSSION_ID, answerPostData.get(Constants.PARENT_DISCUSSION_ID));\n\n            DiscussionEntity jsonNodeEntity = new DiscussionEntity();\n\n            Timestamp currentTime = new Timestamp(System.currentTimeMillis());\n            UUID id = Uuids.timeBased();\n            answerPostDataNode.put(Constants.DISCUSSION_ID, String.valueOf(id));\n            jsonNodeEntity.setDiscussionId(String.valueOf(id));\n            jsonNodeEntity.setCreatedOn(currentTime);\n            answerPostDataNode.put(Constants.CREATED_ON, getFormattedCurrentTime(currentTime));\n            answerPostDataNode.put(Constants.UPDATED_ON, getFormattedCurrentTime(currentTime));\n            jsonNodeEntity.setIsActive(true);\n            answerPostDataNode.put(Constants.IS_ACTIVE, true);\n            jsonNodeEntity.setData(answerPostDataNode);\n            jsonNodeEntity.setCreatedOn(currentTime);\n            jsonNodeEntity.setUpdatedOn(currentTime);\n            long timer = System.currentTimeMillis();\n            discussionRepository.save(jsonNodeEntity);\n            updateMetricsDbOperation(Constants.DISCUSSION_ANSWER_POST, Constants.POSTGRES, Constants.INSERT, timer);\n\n            ObjectNode jsonNode = objectMapper.createObjectNode();\n            jsonNode.setAll(answerPostDataNode);\n            Map<String, Object> map = objectMapper.convertValue(jsonNode, Map.class);\n            esUtilService.addDocument(cbServerProperties.getDiscussionEntity(), String.valueOf(id), map, cbServerProperties.getElasticDiscussionJsonPath());\n            cacheService.putCache(Constants.DISCUSSION_CACHE_PREFIX + String.valueOf(id), jsonNode);\n\n            updateAnswerPostToDiscussion(discussionEntity, String.valueOf(id), Constants.INCREMENT);\n            deleteCacheByCommunity(Constants.DISCUSSION_CACHE_PREFIX + answerPostData.get(Constants.COMMUNITY_ID).asText());\n            updateCacheForFirstFivePages(answerPostData.get(Constants.COMMUNITY_ID).asText(), false);\n            redisTemplate.opsForValue()\n                    .getAndDelete(DiscussionServiceUtil.generateRedisJwtTokenKey(createSearchCriteriaWithDefaults(\n                            answerPostData.get(Constants.PARENT_DISCUSSION_ID).asText(),\n                            answerPostData.get(Constants.COMMUNITY_ID).asText(),\n                            Constants.ANSWER_POST)));\n            // update global feed cache\n            updateCacheForGlobalFeed(userId);\n            Map<String, String> communityObject = new HashMap<>();\n            communityObject.put(Constants.COMMUNITY_ID, answerPostData.get(Constants.COMMUNITY_ID).asText());\n            communityObject.put(Constants.STATUS, Constants.INCREMENT);\n            communityObject.put(Constants.TYPE, Constants.ANSWER_POST);\n            producer.push(cbServerProperties.getCommunityPostCount(), communityObject);\n\n            log.info(\"AnswerPost created successfully\");\n            map.put(Constants.CREATED_ON, currentTime);\n            response.setResponseCode(HttpStatus.CREATED);\n            response.getParams().setStatus(Constants.SUCCESS);\n            response.setResult(map);\n        } catch (Exception e) {\n            log.error(\"Failed to create AnswerPost: {}\", e.getMessage(), e);\n            DiscussionServiceUtil.createErrorResponse(response, Constants.FAILED_TO_CREATE_ANSWER_POST, HttpStatus.INTERNAL_SERVER_ERROR, Constants.FAILED);\n            return response;\n        }\n        return response;\n    }\n\n    private SearchCriteria createSearchCriteriaWithDefaults(String parentDiscussionId,\n                                                            String communityId,\n                                                            String type) {\n        SearchCriteria criteria = new SearchCriteria();\n\n        // Initialize filterCriteriaMap with default and specified values\n        HashMap<String, Object> filterMap = new HashMap<>();\n        filterMap.put(Constants.COMMUNITY_ID, communityId);\n        filterMap.put(Constants.TYPE, type);\n        filterMap.put(Constants.PARENT_DISCUSSION_ID, parentDiscussionId);\n        criteria.setFilterCriteriaMap(filterMap);\n        // Initialize requestedFields with an empty list\n        criteria.setRequestedFields(Collections.emptyList());\n\n        // Set default pagination values\n        criteria.setPageNumber(0);\n        criteria.setPageSize(10);\n\n        // Set default ordering\n        criteria.setOrderBy(Constants.CREATED_ON);\n        criteria.setOrderDirection(Constants.DESC);\n\n        // Initialize facets with an empty list\n        criteria.setFacets(Collections.emptyList());\n        return criteria;\n\n    }\n\n    private void updateAnswerPostToDiscussion(DiscussionEntity discussionEntity, String discussionId, String action) {\n        log.info(\"DiscussionService::updateAnswerPostToDiscussion:inside\");\n        JsonNode data = discussionEntity.getData();\n        Set<String> answerPostSet = new HashSet<>();\n\n        if (data.has(Constants.ANSWER_POSTS)) {\n            ArrayNode existingAnswerPosts = (ArrayNode) data.get(Constants.ANSWER_POSTS);\n            existingAnswerPosts.forEach(post -> answerPostSet.add(post.asText()));\n        }\n        if (Constants.INCREMENT.equals(action)) {\n            answerPostSet.add(discussionId);\n        } else {\n            answerPostSet.remove(discussionId);\n        }\n        ArrayNode arrayNode = objectMapper.valueToTree(answerPostSet);\n        ((ObjectNode) data).put(Constants.ANSWER_POSTS, arrayNode);\n        ((ObjectNode) data).put(Constants.ANSWER_POST_COUNT, answerPostSet.size());\n\n        discussionEntity.setData(data);\n        DiscussionEntity savedEntity = discussionRepository.save(discussionEntity);\n        log.info(\"DiscussionService::updateAnswerPostToDiscussion: Discussion entity updated successfully\");\n\n        ObjectNode jsonNode = objectMapper.createObjectNode();\n        jsonNode.setAll((ObjectNode) savedEntity.getData());\n        Map<String, Object> map = objectMapper.convertValue(jsonNode, Map.class);\n\n        esUtilService.updateDocument(cbServerProperties.getDiscussionEntity(), discussionEntity.getDiscussionId(), map, cbServerProperties.getElasticDiscussionJsonPath());\n        cacheService.putCache(Constants.DISCUSSION_CACHE_PREFIX + discussionEntity.getDiscussionId(), jsonNode);\n    }\n\n    @Override\n    public ApiResponse upVote(String discussionId, String type, String token) {\n        return vote(discussionId, type, token, Constants.UP);\n    }\n\n    @Override\n    public ApiResponse downVote(String discussionId, String type, String token) {\n        return vote(discussionId, type, token, Constants.DOWN);\n    }\n\n    @Override\n    public ApiResponse report(String token, Map<String, Object> reportData) {\n        log.info(\"DiscussionService::report: Reporting discussion\");\n        ApiResponse response = ProjectUtil.createDefaultResponse(\"discussion.report\");\n        String errorMsg = validateReportPayload(reportData);\n        if (StringUtils.isNotEmpty(errorMsg)) {\n            return ProjectUtil.returnErrorMsg(errorMsg, HttpStatus.BAD_REQUEST, response, Constants.FAILED);\n        }\n\n        String userId = accessTokenValidator.verifyUserToken(token);\n        if (StringUtils.isBlank(userId) || Constants.UNAUTHORIZED.equals(userId)) {\n            return ProjectUtil.returnErrorMsg(Constants.INVALID_AUTH_TOKEN, HttpStatus.UNAUTHORIZED, response, Constants.FAILED);\n        }\n\n        try {\n            String discussionId = (String) reportData.get(Constants.DISCUSSION_ID);\n            String discussionText = (String) reportData.get(Constants.DISCUSSION_TEXT);\n            String type = (String) reportData.get(Constants.TYPE);\n            Object entityObject = Constants.ANSWER_POST_REPLY.equals(type)\n                    ? discussionAnswerPostReplyRepository.findById(discussionId).orElse(null)\n                    : discussionRepository.findById(discussionId).orElse(null);\n\n            if (entityObject == null) {\n                return ProjectUtil.returnErrorMsg(Constants.DISCUSSION_NOT_FOUND, HttpStatus.NOT_FOUND, response, Constants.FAILED);\n            }\n\n            JsonNode dataNode;\n            Boolean isActive;\n            if (Constants.ANSWER_POST_REPLY.equals(type)) {\n                DiscussionAnswerPostReplyEntity replyEntity = (DiscussionAnswerPostReplyEntity) entityObject;\n                dataNode = replyEntity.getData();\n                isActive = replyEntity.getIsActive();\n            } else {\n                DiscussionEntity discussionEntity = (DiscussionEntity) entityObject;\n                dataNode = discussionEntity.getData();\n                isActive = discussionEntity.getIsActive();\n            }\n\n            ObjectNode data = (ObjectNode) dataNode;\n            if (!isActive) {\n                return ProjectUtil.returnErrorMsg(Constants.DISCUSSION_IS_INACTIVE, HttpStatus.CONFLICT, response, Constants.FAILED);\n            }\n\n            if (!type.equals(data.get(Constants.TYPE).asText())) {\n                return ProjectUtil.returnErrorMsg(Constants.INVALID_TYPE + type, HttpStatus.BAD_REQUEST, response, Constants.FAILED);\n            }\n\n            if (Constants.SUSPENDED.equals(data.get(Constants.STATUS).asText())) {\n                return ProjectUtil.returnErrorMsg(Constants.DISCUSSION_SUSPENDED, HttpStatus.CONFLICT, response, Constants.FAILED);\n            }\n\n            // Check if the user has already reported the discussion\n            Map<String, Object> reportCheckData = new HashMap<>();\n            reportCheckData.put(Constants.USERID, userId);\n            reportCheckData.put(Constants.DISCUSSION_ID, discussionId);\n            List<Map<String, Object>> existingReports = cassandraOperation.getRecordsByPropertiesWithoutFiltering(\n                    Constants.KEYSPACE_SUNBIRD, Constants.DISCUSSION_POST_REPORT_LOOKUP_BY_USER, reportCheckData, null, null);\n\n            if (!existingReports.isEmpty()) {\n                return ProjectUtil.returnErrorMsg(\"User has already reported this post\", HttpStatus.ALREADY_REPORTED, response, Constants.SUCCESS);\n            }\n\n            // Store user data in Cassandra\n            Map<String, Object> userReportData = new HashMap<>();\n            userReportData.put(Constants.USERID, userId);\n            userReportData.put(Constants.DISCUSSION_ID, discussionId);\n            if (StringUtils.isNotBlank(discussionText)) {\n                userReportData.put(Constants.DISCUSSION_TEXT, discussionText);\n            }\n            if (reportData.containsKey(Constants.REPORTED_REASON)) {\n                List<String> reportedReasonList = (List<String>) reportData.get(Constants.REPORTED_REASON);\n                if (reportedReasonList != null && !reportedReasonList.isEmpty()) {\n                    StringBuilder reasonBuilder = new StringBuilder(String.join(\", \", reportedReasonList));\n\n                    if (reportedReasonList.contains(Constants.OTHERS) && reportData.containsKey(Constants.OTHER_REASON)) {\n                        reasonBuilder.append(\", \").append(reportData.get(Constants.OTHER_REASON));\n                    }\n                    userReportData.put(Constants.REASON, reasonBuilder.toString());\n                }\n            }\n            Instant now = Instant.now();\n            Timestamp currentTime = Timestamp.from(now);\n            data.put(Constants.RECENT_REPORTED_ON, getFormattedCurrentTime(currentTime));\n            userReportData.put(Constants.CREATED_ON, now);\n            cassandraOperation.insertRecord(Constants.KEYSPACE_SUNBIRD, Constants.DISCUSSION_POST_REPORT_LOOKUP_BY_USER, userReportData);\n            cassandraOperation.insertRecord(Constants.KEYSPACE_SUNBIRD, Constants.DISCUSSION_POST_REPORT_LOOKUP_BY_POST, userReportData);\n\n            // Update the status of the discussion in Cassandra\n            String status;\n            if (cbServerProperties.isDiscussionReportHidePost()) {\n                List<Map<String, Object>> reportedByUsers = cassandraOperation.getRecordsByPropertiesWithoutFiltering(\n                        Constants.KEYSPACE_SUNBIRD, Constants.DISCUSSION_POST_REPORT_LOOKUP_BY_POST, Collections.singletonMap(Constants.DISCUSSION_ID, discussionId), null, null);\n                status = CollectionUtils.isNotEmpty(reportedByUsers) && reportedByUsers.size() >= cbServerProperties.getReportPostUserLimit()\n                        ? Constants.SUSPENDED\n                        : Constants.REPORTED;\n            } else {\n                status = Constants.REPORTED;\n            }\n\n            ObjectNode jsonNode = objectMapper.createObjectNode();\n            if (!data.get(Constants.STATUS).textValue().equals(status)) {\n                data.put(Constants.STATUS, status);\n            }\n\n            ArrayNode reportedByArray;\n            if (data.has(Constants.REPORTED_BY)) {\n                reportedByArray = (ArrayNode) data.get(Constants.REPORTED_BY);\n            } else {\n                reportedByArray = objectMapper.createArrayNode();\n                data.set(Constants.REPORTED_BY, reportedByArray);\n            }\n            reportedByArray.add(userId);\n            if (Constants.ANSWER_POST_REPLY.equals(type)) {\n                DiscussionAnswerPostReplyEntity replyEntity = (DiscussionAnswerPostReplyEntity) entityObject;\n                replyEntity.setData(dataNode);\n                discussionAnswerPostReplyRepository.save(replyEntity);\n            } else {\n                DiscussionEntity discussionEntity = (DiscussionEntity) entityObject;\n                discussionEntity.setData(dataNode);\n                discussionRepository.save(discussionEntity);\n            }\n            jsonNode.setAll(data);\n            Map<String, Object> map = objectMapper.convertValue(jsonNode, Map.class);\n            esUtilService.updateDocument(cbServerProperties.getDiscussionEntity(), discussionId, map, cbServerProperties.getElasticDiscussionJsonPath());\n            cacheService.putCache(Constants.DISCUSSION_CACHE_PREFIX + discussionId, jsonNode);\n\n            if (Constants.ANSWER_POST_REPLY.equals(type)) {\n                redisTemplate.opsForValue()\n                        .getAndDelete(DiscussionServiceUtil.generateRedisJwtTokenKey(createDefaultSearchCriteria(\n                                data.get(Constants.PARENT_ANSWER_POST_ID).asText(),\n                                data.get(Constants.COMMUNITY_ID).asText())));\n            } else {\n                deleteCacheByCommunity(Constants.DISCUSSION_CACHE_PREFIX + data.get(Constants.COMMUNITY_ID).asText());\n                updateCacheForFirstFivePages(data.get(Constants.COMMUNITY_ID).asText(), false);\n                updateCacheForGlobalFeed(userId);\n            }\n            log.info(\"Updated cache for global feed\");\n            map.put(Constants.DISCUSSION_ID, reportData.get(Constants.DISCUSSION_ID));\n            response.setResult(map);\n            return response;\n        } catch (Exception e) {\n            log.error(\"DiscussionService::report: Failed to report discussion\", e);\n            return ProjectUtil.returnErrorMsg(Constants.DISCUSSION_REPORT_FAILED, HttpStatus.INTERNAL_SERVER_ERROR, response, Constants.FAILED);\n        }\n    }\n\n    private String validateReportPayload(Map<String, Object> reportData) {\n        StringBuffer errorMsg = new StringBuffer();\n        List<String> errList = new ArrayList<>();\n\n        if (reportData.containsKey(Constants.DISCUSSION_ID) && StringUtils.isBlank((String) reportData.get(Constants.DISCUSSION_ID))) {\n            errList.add(Constants.DISCUSSION_ID);\n        }\n        if (reportData.containsKey(Constants.TYPE) && StringUtils.isBlank((String) reportData.get(Constants.TYPE))) {\n            errList.add(Constants.TYPE);\n        }\n        if (reportData.containsKey(Constants.REPORTED_REASON)) {\n            Object reportedReasonObj = reportData.get(Constants.REPORTED_REASON);\n            if (reportedReasonObj instanceof List) {\n                List<String> reportedReasonList = (List<String>) reportedReasonObj;\n                if (reportedReasonList.isEmpty()) {\n                    errList.add(Constants.REPORTED_REASON);\n                } else if (reportedReasonList.contains(Constants.OTHERS)) {\n                    if (!reportData.containsKey(Constants.OTHER_REASON) ||\n                            StringUtils.isBlank((String) reportData.get(Constants.OTHER_REASON))) {\n                        errList.add(Constants.OTHER_REASON);\n                    }\n                }\n            } else {\n                errList.add(Constants.REPORTED_REASON);\n            }\n        }\n        if (!errList.isEmpty()) {\n            errorMsg.append(\"Failed Due To Missing Params - \").append(errList).append(\".\");\n        }\n        return errorMsg.toString();\n    }\n\n\n    @Override\n    public ApiResponse uploadFile(MultipartFile mFile, String communityId, String discussionId) {\n        ApiResponse response = ProjectUtil.createDefaultResponse(Constants.DISCUSSION_UPLOAD_FILE);\n        if (mFile.isEmpty()) {\n            return ProjectUtil.returnErrorMsg(Constants.DISCUSSION_FILE_EMPTY, HttpStatus.BAD_REQUEST, response, Constants.FAILED);\n        }\n        if (StringUtils.isBlank(discussionId)) {\n            return ProjectUtil.returnErrorMsg(Constants.INVALID_DISCUSSION_ID, HttpStatus.BAD_REQUEST, response, Constants.FAILED);\n        }\n        if (StringUtils.isBlank(communityId)) {\n            return ProjectUtil.returnErrorMsg(Constants.INVALID_COMMUNITY_ID, HttpStatus.BAD_REQUEST, response, Constants.FAILED);\n        }\n\n        File file = null;\n        try {\n            file = new File(System.currentTimeMillis() + Constants.UNDER_SCORE + mFile.getOriginalFilename());\n\n            file.createNewFile();\n            // Use try-with-resources to ensure FileOutputStream is closed\n            try (FileOutputStream fos = new FileOutputStream(file)) {\n                fos.write(mFile.getBytes());\n            }\n\n            String uploadFolderPath = cbServerProperties.getDiscussionCloudFolderName() + \"/\" + communityId + \"/\" + discussionId;\n            return uploadFile(file, uploadFolderPath, cbServerProperties.getDiscussionContainerName());\n        } catch (Exception e) {\n            log.error(\"Failed to upload file. Exception: \", e);\n            response.getParams().setStatus(Constants.FAILED);\n            response.getParams().setErrMsg(\"Failed to upload file. Exception: \" + e.getMessage());\n            response.setResponseCode(HttpStatus.INTERNAL_SERVER_ERROR);\n            return response;\n        } finally {\n            if (file != null && file.exists()) {\n                file.delete();\n            }\n        }\n    }\n\n    public ApiResponse uploadFile(File file, String cloudFolderName, String containerName) {\n        ApiResponse response = ProjectUtil.createDefaultResponse(Constants.UPLOAD_FILE);\n        try {\n            String objectKey = cloudFolderName + \"/\" + file.getName();\n            String url = storageService.upload(containerName, file.getAbsolutePath(),\n                    objectKey, Option.apply(false), Option.apply(1), Option.apply(5), Option.empty());\n            Map<String, String> uploadedFile = new HashMap<>();\n            uploadedFile.put(Constants.NAME, file.getName());\n            uploadedFile.put(Constants.URL, url);\n            response.getResult().putAll(uploadedFile);\n            return response;\n        } catch (Exception e) {\n            log.error(\"Failed to upload file. Exception: \", e);\n            response.getParams().setStatus(Constants.FAILED);\n            response.getParams().setErrMsg(\"Failed to upload file. Exception: \" + e.getMessage());\n            response.setResponseCode(HttpStatus.INTERNAL_SERVER_ERROR);\n            return response;\n        }\n    }\n\n    private void updateMetricsDbOperation(String apiName, String dbType, String operationType, long time) {\n        if (ApiMetricsTracker.isTrackingEnabled()) {\n            ApiMetricsTracker.recordDbOperation(apiName, dbType, operationType, System.currentTimeMillis() - time);\n        }\n    }\n\n    private void updateMetricsApiCall(String apiName) {\n        if (ApiMetricsTracker.isTrackingEnabled()) {\n            ApiMetricsTracker.recordApiCall(apiName);\n        }\n    }\n\n    private boolean validateCommunityId(String communityId) {\n        Optional<CommunityEntity> communityEntityOptional = communityEngagementRepository.findByCommunityIdAndIsActive(communityId, true);\n        if (communityEntityOptional.isPresent()) {\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public ApiResponse updateAnswerPost(JsonNode answerPostData, String token) {\n        log.info(\"DiscussionService::updateAnswerPost:updating answerPost\");\n        ApiResponse response = ProjectUtil.createDefaultResponse(\"discussion.updateAnswerPost\");\n        payloadValidation.validatePayload(Constants.ANSWER_POST_UPDATE_VALIDATION_SCHEMA, answerPostData);\n        String userId = accessTokenValidator.verifyUserToken(token);\n        if (StringUtils.isBlank(userId) || userId.equals(Constants.UNAUTHORIZED)) {\n            response.getParams().setErrMsg(Constants.INVALID_AUTH_TOKEN);\n            response.setResponseCode(HttpStatus.BAD_REQUEST);\n            return response;\n        }\n        updateMetricsApiCall(Constants.DISCUSSION_ANSWER_POST);\n        long redisTimer = System.currentTimeMillis();\n        DiscussionEntity discussionEntity = discussionRepository.findById(answerPostData.get(Constants.ANSWER_POST_ID).asText()).orElse(null);\n        updateMetricsDbOperation(Constants.DISCUSSION_ANSWER_POST, Constants.POSTGRES, Constants.READ, redisTimer);\n        if (discussionEntity == null || !discussionEntity.getIsActive()) {\n            return ProjectUtil.returnErrorMsg(Constants.INVALID_DISCUSSION_ID, HttpStatus.BAD_REQUEST, response, Constants.FAILED);\n        }\n        ObjectNode data = (ObjectNode) discussionEntity.getData();\n        String type = data.get(Constants.TYPE).asText();\n        if (!type.equals(Constants.ANSWER_POST)) {\n            return ProjectUtil.returnErrorMsg(Constants.INVALID_ANSWER_POST_ID, HttpStatus.BAD_REQUEST, response, Constants.FAILED);\n        }\n        if (data.get(Constants.STATUS).asText().equals(Constants.SUSPENDED)) {\n            return ProjectUtil.returnErrorMsg(Constants.DISCUSSION_SUSPENDED, HttpStatus.BAD_REQUEST, response, Constants.FAILED);\n        }\n\n        try {\n            ObjectNode answerPostDataNode = (ObjectNode) answerPostData;\n            answerPostDataNode.remove(Constants.ANSWER_POST_ID);\n\n            if (!answerPostDataNode.has(Constants.IS_INITIAL_UPLOAD) || !answerPostDataNode.get(Constants.IS_INITIAL_UPLOAD).asBoolean()) {\n                Timestamp currentTime = new Timestamp(System.currentTimeMillis());\n                answerPostDataNode.put(Constants.UPDATED_ON, getFormattedCurrentTime(currentTime));\n                discussionEntity.setUpdatedOn(currentTime);\n            }\n            data.setAll(answerPostDataNode);\n            discussionEntity.setData(data);\n            long timer = System.currentTimeMillis();\n            discussionRepository.save(discussionEntity);\n            updateMetricsDbOperation(Constants.DISCUSSION_ANSWER_POST, Constants.POSTGRES, Constants.UPDATE, timer);\n\n            ObjectNode jsonNode = objectMapper.createObjectNode();\n            jsonNode.setAll(data);\n            Map<String, Object> map = objectMapper.convertValue(jsonNode, Map.class);\n            esUtilService.updateDocument(cbServerProperties.getDiscussionEntity(), discussionEntity.getDiscussionId(), map, cbServerProperties.getElasticDiscussionJsonPath());\n            cacheService.putCache(Constants.DISCUSSION_CACHE_PREFIX + String.valueOf(discussionEntity.getDiscussionId()), jsonNode);\n            redisTemplate.opsForValue()\n                    .getAndDelete(DiscussionServiceUtil.generateRedisJwtTokenKey(createSearchCriteriaWithDefaults(\n                            data.get(Constants.PARENT_DISCUSSION_ID).asText(),\n                            data.get(Constants.COMMUNITY_ID).asText(),\n                            Constants.ANSWER_POST)));\n            log.info(\"AnswerPost updated successfully\");\n            response.setResponseCode(HttpStatus.OK);\n            response.getParams().setStatus(Constants.SUCCESS);\n            response.setResult(map);\n        } catch (Exception e) {\n            log.error(\"Failed to update AnswerPost: {}\", e.getMessage(), e);\n            DiscussionServiceUtil.createErrorResponse(response, Constants.FAILED_TO_UPDATE_ANSWER_POST, HttpStatus.INTERNAL_SERVER_ERROR, Constants.FAILED);\n            return response;\n        }\n        return response;\n    }\n\n    @Override\n    public ApiResponse bookmarkDiscussion(String token, String communityId, String discussionId) {\n        log.info(\"DiscussionService::bookmarkDiscussion: Bookmarking discussion\");\n        ApiResponse response = ProjectUtil.createDefaultResponse(\"discussion.bookmarkDiscussion\");\n        if (StringUtils.isBlank(discussionId)) {\n            return ProjectUtil.returnErrorMsg(Constants.INVALID_DISCUSSION_ID, HttpStatus.BAD_REQUEST, response, Constants.FAILED);\n        }\n\n        if (StringUtils.isBlank(communityId)) {\n            return ProjectUtil.returnErrorMsg(Constants.INVALID_COMMUNITY_ID, HttpStatus.BAD_REQUEST, response, Constants.FAILED);\n        }\n        String userId = accessTokenValidator.verifyUserToken(token);\n        if (StringUtils.isBlank(userId) || Constants.UNAUTHORIZED.equals(userId)) {\n            return ProjectUtil.returnErrorMsg(Constants.INVALID_AUTH_TOKEN, HttpStatus.UNAUTHORIZED, response, Constants.FAILED);\n        }\n\n        try {\n            Optional<DiscussionEntity> discussionDbData = discussionRepository.findById(discussionId);\n            if (!discussionDbData.isPresent()) {\n                return ProjectUtil.returnErrorMsg(Constants.DISCUSSION_NOT_FOUND, HttpStatus.NOT_FOUND, response, Constants.FAILED);\n            }\n            DiscussionEntity discussionEntity = discussionDbData.get();\n            if (!discussionEntity.getIsActive()) {\n                return ProjectUtil.returnErrorMsg(Constants.DISCUSSION_IS_INACTIVE, HttpStatus.CONFLICT, response, Constants.FAILED);\n            }\n\n            String bookMarkedCommunityId = discussionEntity.getData().get(Constants.COMMUNITY_ID).asText();\n            if (!bookMarkedCommunityId.equals(communityId)) {\n                return ProjectUtil.returnErrorMsg(Constants.INVALID_COMMUNITY_ID, HttpStatus.BAD_REQUEST, response, Constants.FAILED);\n            }\n\n            Map<String, Object> properties = new HashMap<>();\n            properties.put(Constants.USERID, userId);\n            properties.put(Constants.COMMUNITY_ID, communityId);\n            properties.put(Constants.DISCUSSION_ID, discussionId);\n\n            // Check if the bookmark already exists\n            List<Map<String, Object>> existingBookmarks = cassandraOperation.getRecordsByPropertiesWithoutFiltering(\n                    Constants.KEYSPACE_SUNBIRD, Constants.DISCUSSION_BOOKMARKS, properties, Arrays.asList(Constants.STATUS), null);\n\n            if (!existingBookmarks.isEmpty() && (boolean) existingBookmarks.get(0).get(Constants.STATUS)) {\n                return ProjectUtil.returnErrorMsg(Constants.ALREADY_BOOKMARKED, HttpStatus.ALREADY_REPORTED, response, Constants.FAILED);\n            }\n\n            // Insert the new bookmark\n            properties.put(Constants.CREATED_ON, Instant.now());\n            properties.put(Constants.STATUS, true);\n            cassandraOperation.insertRecord(Constants.KEYSPACE_SUNBIRD, Constants.DISCUSSION_BOOKMARKS, properties);\n            cacheService.deleteCache(Constants.DISCUSSION_CACHE_PREFIX + Constants.COMMUNITY + communityId + userId);\n            Map<String, Object> map = new HashMap<>();\n            map.put(Constants.CREATED_ON, properties.get(Constants.CREATED_ON));\n            map.put(Constants.COMMUNITY_ID, communityId);\n            map.put(Constants.DISCUSSION_ID, discussionId);\n            response.setResult(map);\n            return response;\n        } catch (Exception e) {\n            log.error(\"DiscussionService::bookmarkDiscussion: Failed to bookmark discussion\", e);\n            return ProjectUtil.returnErrorMsg(Constants.DISCUSSION_BOOKMARK_FAILED, HttpStatus.INTERNAL_SERVER_ERROR, response, Constants.FAILED);\n        }\n    }\n\n    public ApiResponse unBookmarkDiscussion(String communityId, String discussionId, String token) {\n        log.info(\"DiscussionService::unBookmarkDiscussion: UnBookmarking discussion\");\n        ApiResponse response = ProjectUtil.createDefaultResponse(\"discussion.unBookmarkDiscussion\");\n        if (StringUtils.isBlank(discussionId)) {\n            return ProjectUtil.returnErrorMsg(Constants.INVALID_DISCUSSION_ID, HttpStatus.BAD_REQUEST, response, Constants.FAILED);\n        }\n\n        if (StringUtils.isBlank(communityId)) {\n            return ProjectUtil.returnErrorMsg(Constants.INVALID_COMMUNITY_ID, HttpStatus.BAD_REQUEST, response, Constants.FAILED);\n        }\n        String userId = accessTokenValidator.verifyUserToken(token);\n        if (StringUtils.isBlank(userId) || Constants.UNAUTHORIZED.equals(userId)) {\n            return ProjectUtil.returnErrorMsg(Constants.INVALID_AUTH_TOKEN, HttpStatus.UNAUTHORIZED, response, Constants.FAILED);\n        }\n\n        Map<String, Object> compositeKeys = new HashMap<>();\n        Map<String, Object> properties = new HashMap<>();\n        compositeKeys.put(Constants.COMMUNITY_ID, communityId);\n        compositeKeys.put(Constants.DISCUSSION_ID, discussionId);\n        compositeKeys.put(Constants.USERID, userId);\n        properties.put(Constants.STATUS, false);\n\n        try {\n            cassandraOperation.updateRecordByCompositeKey(Constants.KEYSPACE_SUNBIRD, Constants.DISCUSSION_BOOKMARKS, properties, compositeKeys);\n            cacheService.deleteCache(Constants.DISCUSSION_CACHE_PREFIX + Constants.COMMUNITY + communityId + userId);\n            return response;\n        } catch (Exception e) {\n            log.error(\"DiscussionService::unBookmarkDiscussion: Failed to unBookmark discussion\", e);\n            return ProjectUtil.returnErrorMsg(Constants.DISCUSSION_UN_BOOKMARK_FAILED, HttpStatus.INTERNAL_SERVER_ERROR, response, Constants.FAILED);\n        }\n    }\n\n    @Override\n    public ApiResponse getBookmarkedDiscussions(String token, Map<String, Object> requestData) {\n        log.info(\"DiscussionService::getBookmarkedDiscussions: Fetching bookmarked discussions\");\n        ApiResponse response = ProjectUtil.createDefaultResponse(\"discussion.getBookmarkedDiscussions\");\n        String errorMsg = validateGetBookmarkedDiscussions(requestData);\n\n        if (StringUtils.isNotBlank(errorMsg)) {\n            return ProjectUtil.returnErrorMsg(errorMsg, HttpStatus.BAD_REQUEST, response, Constants.FAILED);\n        }\n        String userId = accessTokenValidator.verifyUserToken(token);\n        if (StringUtils.isBlank(userId) || Constants.UNAUTHORIZED.equals(userId)) {\n            return ProjectUtil.returnErrorMsg(Constants.INVALID_AUTH_TOKEN, HttpStatus.UNAUTHORIZED, response, Constants.FAILED);\n        }\n        try {\n            List<String> cachedKeys = new ArrayList<>();\n            String cachedJson = cacheService.getCache(Constants.DISCUSSION_CACHE_PREFIX + Constants.COMMUNITY + requestData.get(Constants.COMMUNITY_ID) + userId);\n            if (StringUtils.isNotBlank(cachedJson)) {\n                cachedKeys = objectMapper.readValue(cachedJson, new TypeReference<List<String>>() {\n                });\n            } else {\n                Map<String, Object> properties = new HashMap<>();\n                properties.put(Constants.USERID, userId);\n                properties.put(Constants.COMMUNITY_ID, requestData.get(Constants.COMMUNITY_ID));\n                List<Map<String, Object>> bookmarkedDiscussions = cassandraOperation.getRecordsByPropertiesWithoutFiltering(Constants.KEYSPACE_SUNBIRD, Constants.DISCUSSION_BOOKMARKS, properties, Arrays.asList(Constants.DISCUSSION_ID, Constants.STATUS), null);\n                if (bookmarkedDiscussions.isEmpty()) {\n                    return ProjectUtil.returnErrorMsg(Constants.NO_DISCUSSIONS_FOUND, HttpStatus.OK, response, Constants.SUCCESS);\n                }\n                for (Map<String, Object> bookmarkedDiscussion : bookmarkedDiscussions) {\n                    if (Boolean.TRUE.equals(bookmarkedDiscussion.get(Constants.STATUS))) {\n                        cachedKeys.add((String) bookmarkedDiscussion.get(Constants.DISCUSSION_ID_KEY));\n                    }\n                }\n                if (cachedKeys.isEmpty()) {\n                    return ProjectUtil.returnErrorMsg(Constants.NO_DISCUSSIONS_FOUND, HttpStatus.OK, response, Constants.SUCCESS);\n                }\n                cacheService.putCache(Constants.DISCUSSION_CACHE_PREFIX + Constants.COMMUNITY + requestData.get(Constants.COMMUNITY_ID) + userId, cachedKeys);\n            }\n\n            SearchCriteria searchCriteria = new SearchCriteria();\n            HashMap<String, Object> filterCriteria = new HashMap<>();\n            filterCriteria.put(Constants.DISCUSSION_ID, cachedKeys);\n            searchCriteria.setFilterCriteriaMap(filterCriteria);\n            searchCriteria.setPageNumber((int) requestData.get(Constants.PAGE));\n            searchCriteria.setPageSize((int) requestData.get(Constants.PAGE_SIZE));\n            searchCriteria.setOrderDirection(Constants.DESC);\n            searchCriteria.setOrderBy(Constants.CREATED_ON);\n\n            if (requestData.containsKey(Constants.SEARCH_STRING) && StringUtils.isNotBlank((String) requestData.get(Constants.SEARCH_STRING))) {\n                if (((String) requestData.get(Constants.SEARCH_STRING)).length() < 3) {\n                    DiscussionServiceUtil.createErrorResponse(response, Constants.MINIMUM_CHARACTERS_NEEDED, HttpStatus.BAD_REQUEST, Constants.FAILED_CONST);\n                    return response;\n                }\n                searchCriteria.setSearchString((String) requestData.get(Constants.SEARCH_STRING));\n            }\n\n            SearchResult searchResult = redisTemplate.opsForValue().get(DiscussionServiceUtil.generateRedisJwtTokenKey(searchCriteria));\n            if (searchResult == null) {\n                searchResult = esUtilService.searchDocuments(cbServerProperties.getDiscussionEntity(), searchCriteria, cbServerProperties.getElasticDiscussionJsonPath());\n                List<Map<String, Object>> data = searchResult.getData();\n                fetchAndEnhanceDiscussions(data, false);\n                searchResult.setData(data);\n                redisTemplate.opsForValue().set(DiscussionServiceUtil.generateRedisJwtTokenKey(searchCriteria), searchResult, cbServerProperties.getSearchResultRedisTtl(), TimeUnit.SECONDS);\n            }\n\n            HashMap<String, Object> result = new HashMap<>();\n            result.put(Constants.SEARCH_RESULTS, searchResult);\n            response.setResult(result);\n            return response;\n        } catch (Exception e) {\n            log.error(\"DiscussionService::getBookmarkedDiscussions: Failed to fetch bookmarked discussions\", e);\n            return ProjectUtil.returnErrorMsg(Constants.DISCUSSION_BOOKMARK_FETCH_FAILED, HttpStatus.INTERNAL_SERVER_ERROR, response, Constants.FAILED);\n        }\n    }\n\n    private String validateGetBookmarkedDiscussions(Map<String, Object> requestData) {\n        if (requestData == null) {\n            return Constants.MISSING_REQUEST_DATA;\n        }\n\n        StringBuffer errorMsg = new StringBuffer();\n        List<String> errList = new ArrayList<>();\n\n        if (!requestData.containsKey(Constants.COMMUNITY_ID) && StringUtils.isBlank((String) requestData.get(Constants.COMMUNITY_ID))) {\n            errList.add(Constants.COMMUNITY_ID);\n        }\n        if (!requestData.containsKey(Constants.PAGE) || !(requestData.get(Constants.PAGE) instanceof Integer)) {\n            errList.add(Constants.PAGE);\n        }\n        if (!requestData.containsKey(Constants.PAGE_SIZE) || !(requestData.get(Constants.PAGE_SIZE) instanceof Integer)) {\n            errList.add(Constants.PAGE_SIZE);\n        }\n        if (!errList.isEmpty()) {\n            errorMsg.append(\"Failed Due To Missing Params - \").append(errList).append(\".\");\n        }\n        return errorMsg.toString();\n    }\n\n    private void fetchAndEnhanceDiscussions(List<Map<String, Object>> discussions, boolean isAnswerPost) {\n        Map<String, String> discussionToCreatedByMap = discussions.stream()\n                .collect(Collectors.toMap(\n                        discussion -> discussion.get(Constants.DISCUSSION_ID).toString(),\n                        discussion -> discussion.get(Constants.CREATED_BY).toString()));\n\n        Map<String, List<String>> discussionToUserTagMap = new HashMap<>();\n        if (isAnswerPost) {\n            discussionToUserTagMap.putAll(discussions.stream()\n                    .filter(discussion -> discussion.containsKey(Constants.TAGGED_USER))\n                    .collect(Collectors.toMap(\n                            discussion -> discussion.get(Constants.DISCUSSION_ID).toString(),\n                            discussion -> (List<String>) discussion.get(Constants.TAGGED_USER))));\n        }\n\n        Set<String> createdByIds = new HashSet<>(discussionToCreatedByMap.values());\n        Set<String> userTagIds = new HashSet<>();\n        if (!discussionToUserTagMap.isEmpty()) {\n            userTagIds = discussionToUserTagMap.values().stream()\n                    .flatMap(Collection::stream)\n                    .collect(Collectors.toSet());\n        }\n        Set<String> allUserIds = new HashSet<>();\n        allUserIds.addAll(createdByIds);\n        allUserIds.addAll(userTagIds);\n\n        long userDataRedisTime = System.currentTimeMillis();\n        List<Object> redisResults = fetchDataForKeys(\n                allUserIds.stream().map(id -> Constants.USER_PREFIX + id).collect(Collectors.toList()), true\n        );\n        updateMetricsDbOperation(Constants.DISCUSSION_SEARCH, Constants.REDIS, Constants.READ, userDataRedisTime);\n        Map<String, Object> userDetailsMap = redisResults.stream()\n                .map(user -> (Map<String, Object>) user)\n                .collect(Collectors.toMap(\n                        user -> user.get(Constants.USER_ID_KEY).toString(),\n                        user -> user));\n\n        List<String> missingUserIds = allUserIds.stream()\n                .filter(id -> !userDetailsMap.containsKey(id))\n                .collect(Collectors.toList());\n\n        if (!missingUserIds.isEmpty()) {\n            List<Object> cassandraResults = fetchUserFromPrimary(missingUserIds);\n            userDetailsMap.putAll(cassandraResults.stream()\n                    .map(user -> (Map<String, Object>) user)\n                    .collect(Collectors.toMap(\n                            user -> user.get(Constants.USER_ID_KEY).toString(),\n                            user -> user)));\n        }\n\n        discussions.forEach(discussion -> {\n            String discussionId = discussion.get(Constants.DISCUSSION_ID).toString();\n            String createdById = discussionToCreatedByMap.get(discussionId);\n            List<String> userTagIdsList = discussionToUserTagMap.get(discussionId);\n            boolean hasCreatedBy = createdById != null && userDetailsMap.containsKey(createdById);\n            if (hasCreatedBy) {\n                discussion.put(Constants.CREATED_BY, userDetailsMap.get(createdById));\n            }\n            if (isAnswerPost && userTagIdsList != null && !userTagIdsList.isEmpty()) {\n                List<Object> userTags = userTagIdsList.stream()\n                        .filter(userDetailsMap::containsKey)\n                        .map(userDetailsMap::get)\n                        .collect(Collectors.toList());\n                discussion.put(Constants.TAGGED_USER, userTags);\n            }\n        });\n    }\n\n    @Override\n    public ApiResponse searchDiscussionByCommunity(Map<String, Object> searchData) {\n        log.info(\"DiscussionServiceImpl::searchDiscussionByCommunity\");\n        ApiResponse response = ProjectUtil.createDefaultResponse(\"search.discussion.by.community\");\n        String error = validateCommunitySearchRequest(searchData);\n        if (StringUtils.isNotEmpty(error)) {\n            DiscussionServiceUtil.createErrorResponse(response, error, HttpStatus.BAD_REQUEST, Constants.FAILED_CONST);\n            return response;\n        }\n\n        try {\n            String cacheKey = Constants.DISCUSSION_CACHE_PREFIX + searchData.get(Constants.COMMUNITY_ID) + Constants.UNDER_SCORE + searchData.get(Constants.PAGE_NUMBER);\n            SearchResult searchResult = redisTemplate.opsForValue().get(cacheKey);\n\n            if (searchResult != null) {\n                log.info(\"DiscussionServiceImpl::searchDiscussionByCommunity: search result fetched from redis\");\n                response.getResult().put(Constants.SEARCH_RESULTS, searchResult);\n                DiscussionServiceUtil.createSuccessResponse(response);\n                return response;\n            }\n\n            SearchCriteria searchCriteria = getCriteria((int) searchData.get(Constants.PAGE_NUMBER), cbServerProperties.getDiscussionEsDefaultPageSize());\n            Map<String, Object> filterCriteria = new HashMap<>();\n            filterCriteria.put(Constants.COMMUNITY_ID, searchData.get(Constants.COMMUNITY_ID));\n            filterCriteria.put(Constants.TYPE, Constants.QUESTION);\n            filterCriteria.put(Constants.STATUS, Arrays.asList(Constants.ACTIVE, Constants.REPORTED));\n            filterCriteria.put(Constants.IS_ACTIVE, true);\n\n            searchCriteria.getFilterCriteriaMap().putAll(filterCriteria);\n            searchResult = esUtilService.searchDocuments(cbServerProperties.getDiscussionEntity(), searchCriteria, cbServerProperties.getElasticDiscussionJsonPath());\n            List<Map<String, Object>> discussions = searchResult.getData();\n\n            if (searchCriteria.getRequestedFields().contains(Constants.CREATED_BY) || searchCriteria.getRequestedFields().isEmpty()) {\n                fetchAndEnhanceDiscussions(discussions, false);\n            }\n\n            searchResult.setData(discussions);\n            redisTemplate.opsForValue().set(cacheKey, searchResult, cbServerProperties.getDiscussionFeedRedisTtl(), TimeUnit.SECONDS);\n            response.getResult().put(Constants.SEARCH_RESULTS, searchResult);\n            DiscussionServiceUtil.createSuccessResponse(response);\n            return response;\n        } catch (Exception e) {\n            log.error(\"error while searching discussion by community: {} .\", e.getMessage(), e);\n            DiscussionServiceUtil.createErrorResponse(response, e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR, Constants.FAILED_CONST);\n            return response;\n        }\n    }\n\n    private SearchCriteria getCriteria(int pageNumber, int pageSize) {\n        SearchCriteria searchCriteria = new SearchCriteria();\n        searchCriteria.setPageNumber(pageNumber);\n        searchCriteria.setPageSize(pageSize);\n        searchCriteria.setOrderBy(Constants.CREATED_ON);\n        searchCriteria.setOrderDirection(Constants.DESC);\n        searchCriteria.setFilterCriteriaMap(new HashMap<>());\n        searchCriteria.setRequestedFields(new ArrayList<>());\n        return searchCriteria;\n    }\n\n    private String validateCommunitySearchRequest(Map<String, Object> searchData) {\n\n        if (searchData == null) {\n            return Constants.MISSING_REQUEST_DATA;\n        }\n\n        StringBuffer errorMsg = new StringBuffer();\n        List<String> errList = new ArrayList<>();\n\n        if (!searchData.containsKey(Constants.COMMUNITY_ID) && StringUtils.isBlank((String) searchData.get(Constants.COMMUNITY_ID))) {\n            errList.add(Constants.COMMUNITY_ID);\n        }\n        if (!searchData.containsKey(Constants.PAGE_NUMBER) || !(searchData.get(Constants.PAGE_NUMBER) instanceof Integer)) {\n            errList.add(Constants.PAGE_NUMBER);\n        }\n        if (!errList.isEmpty()) {\n            errorMsg.append(\"Failed Due To Missing Params - \").append(errList).append(\".\");\n        }\n        return errorMsg.toString();\n    }\n\n    private void deleteCacheByCommunity(String prefix) {\n        String pattern = prefix + \"_*\";\n        Set<String> keys = redisTemplate.keys(pattern);\n        if (!keys.isEmpty()) {\n            redisTemplate.delete(keys);\n            log.info(\"Deleted cache keys: {}\", keys);\n        } else {\n            log.info(\"No cache keys found for pattern: {}\", pattern);\n        }\n    }\n\n    private void updateCacheForFirstFivePages(String communityId, boolean isDocumentType) {\n        SearchCriteria searchCriteria = getCriteria(0, 5 * cbServerProperties.getDiscussionEsDefaultPageSize());\n        Map<String, Object> filterCriteria = new HashMap<>();\n        filterCriteria.put(Constants.COMMUNITY_ID, communityId);\n        filterCriteria.put(Constants.TYPE, Constants.QUESTION);\n        if (isDocumentType) {\n            filterCriteria.put(Constants.CATEGORY_TYPE, Arrays.asList(Constants.DOCUMENT));\n        }\n        filterCriteria.put(Constants.STATUS, Arrays.asList(Constants.ACTIVE, Constants.REPORTED));\n        filterCriteria.put(Constants.IS_ACTIVE, true);\n        searchCriteria.getFilterCriteriaMap().putAll(filterCriteria);\n\n        try {\n            SearchResult searchResult = esUtilService.searchDocuments(cbServerProperties.getDiscussionEntity(), searchCriteria, cbServerProperties.getElasticDiscussionJsonPath());\n            List<Map<String, Object>> discussions = searchResult.getData();\n\n            if (searchCriteria.getRequestedFields().contains(Constants.CREATED_BY) || searchCriteria.getRequestedFields().isEmpty()) {\n                fetchAndEnhanceDiscussions(discussions, false);\n            }\n\n            String cacheKeyPrefix;\n            if (isDocumentType) {\n                cacheKeyPrefix = Constants.DISCUSSION_DOCUMENT_POST + communityId + Constants.UNDER_SCORE;\n            } else {\n                cacheKeyPrefix = Constants.DISCUSSION_CACHE_PREFIX + communityId + Constants.UNDER_SCORE;\n            }\n\n            for (int pageNumber = 1; pageNumber <= 5; pageNumber++) {\n                int fromIndex = (pageNumber - 1) * cbServerProperties.getDiscussionEsDefaultPageSize();\n                if (fromIndex >= discussions.size()) {\n                    break;\n                }\n                int toIndex = Math.min(fromIndex + cbServerProperties.getDiscussionEsDefaultPageSize(), discussions.size());\n                List<Map<String, Object>> pageDiscussions = new ArrayList<>(discussions.subList(fromIndex, toIndex));\n\n                String cacheKey = cacheKeyPrefix + (pageNumber - 1);\n                SearchResult pageResult = new SearchResult();\n                pageResult.setData(pageDiscussions);\n                pageResult.setTotalCount(searchResult.getTotalCount());\n                pageResult.setFacets(searchResult.getFacets());\n                redisTemplate.opsForValue().set(cacheKey, pageResult, cbServerProperties.getDiscussionFeedRedisTtl(), TimeUnit.SECONDS);\n            }\n        } catch (Exception e) {\n            log.error(\"Error while updating cache for community {}: {}\", communityId, e.getMessage(), e);\n        }\n    }\n\n    private String getFormattedCurrentTime(Timestamp currentTime) {\n        ZonedDateTime zonedDateTime = currentTime.toInstant().atZone(ZoneId.systemDefault());\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(Constants.TIME_FORMAT);\n        return zonedDateTime.format(formatter);\n    }\n\n    private String generateRedisTokenKey(SearchCriteria searchCriteria) {\n        if (searchCriteria != null) {\n\n            try {\n                if (searchCriteria.getFilterCriteriaMap() != null\n                        && searchCriteria.getFilterCriteriaMap().size() == cbServerProperties.getUserFeedFilterCriteriaMapSize()\n                        && searchCriteria.getFilterCriteriaMap().containsKey(Constants.CREATED_BY)\n                        && searchCriteria.getFilterCriteriaMap().get(Constants.CREATED_BY) instanceof String\n                        && searchCriteria.getFilterCriteriaMap().containsKey(Constants.COMMUNITY_ID)\n                        && searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID) instanceof String) {\n\n                    SearchCriteria tempSearchCriteria = objectMapper.readValue(cbServerProperties.getFilterCriteriaQuestionUserFeed(), SearchCriteria.class);\n                    if (tempSearchCriteria != null && tempSearchCriteria.getFilterCriteriaMap() != null) {\n                        tempSearchCriteria.getFilterCriteriaMap().put(Constants.COMMUNITY_ID, searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID));\n                        tempSearchCriteria.getFilterCriteriaMap().put(Constants.CREATED_BY, searchCriteria.getFilterCriteriaMap().get(Constants.CREATED_BY));\n                        tempSearchCriteria.setPageNumber(searchCriteria.getPageNumber());\n\n                        if (tempSearchCriteria.equals(searchCriteria)) {\n                            return Constants.DISCUSSION_POSTS_BY_USER\n                                    + searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID)\n                                    + Constants.UNDER_SCORE\n                                    + searchCriteria.getFilterCriteriaMap().get(Constants.CREATED_BY)\n                                    + Constants.UNDER_SCORE\n                                    + searchCriteria.getPageNumber();\n                        }\n                    }\n                }\n                if (searchCriteria.getFilterCriteriaMap() != null\n                        && searchCriteria.getFilterCriteriaMap().containsKey(Constants.COMMUNITY_ID)\n                        && searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID) instanceof String\n                        && searchCriteria.getFilterCriteriaMap().containsKey(Constants.CATEGORY_TYPE)) {\n                    SearchCriteria tempSearchCriteria = objectMapper.readValue(cbServerProperties.getFilterCriteriaQuestionDocumentFeed(), SearchCriteria.class);\n                    if (tempSearchCriteria != null && tempSearchCriteria.getFilterCriteriaMap() != null) {\n                        tempSearchCriteria.getFilterCriteriaMap().put(Constants.COMMUNITY_ID, searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID));\n                        tempSearchCriteria.setPageNumber(searchCriteria.getPageNumber());\n\n                        if (tempSearchCriteria.equals(searchCriteria)) {\n                            return Constants.DISCUSSION_DOCUMENT_POST + searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID)\n                                    + Constants.UNDER_SCORE\n                                    + searchCriteria.getPageNumber();\n                        }\n                    }\n                }\n\n                if (searchCriteria.getFilterCriteriaMap() != null\n                        && searchCriteria.getFilterCriteriaMap().containsKey(Constants.COMMUNITY_ID)\n                        && searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID) instanceof String\n                        && searchCriteria.getFilterCriteriaMap().get(Constants.STATUS) instanceof List) {\n                    SearchCriteria tempSearchCriteria = objectMapper.readValue(cbServerProperties.getMdoAllReportFeed(), SearchCriteria.class);\n                    if (tempSearchCriteria != null && tempSearchCriteria.getFilterCriteriaMap() != null) {\n                        tempSearchCriteria.getFilterCriteriaMap().put(Constants.COMMUNITY_ID, searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID));\n                        tempSearchCriteria.setPageNumber(searchCriteria.getPageNumber());\n\n                        if (tempSearchCriteria.equals(searchCriteria)) {\n                            return Constants.ALL_REPORTED_POSTS_CACHE_PREFIX + searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID) + Constants.UNDER_SCORE + searchCriteria.getPageNumber();\n                        }\n                    }\n                }\n\n                if (searchCriteria.getFilterCriteriaMap() != null\n                        && searchCriteria.getFilterCriteriaMap().containsKey(Constants.STATUS)\n                        && searchCriteria.getFilterCriteriaMap().containsKey(Constants.COMMUNITY_ID)\n                        && searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID) instanceof String) {\n\n                    SearchCriteria tempSearchCriteria = objectMapper.readValue(cbServerProperties.getMdoQuestionReportFeed(), SearchCriteria.class);\n                    if (tempSearchCriteria != null && tempSearchCriteria.getFilterCriteriaMap() != null) {\n                        tempSearchCriteria.getFilterCriteriaMap().put(Constants.COMMUNITY_ID, searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID));\n                        tempSearchCriteria.setPageNumber(searchCriteria.getPageNumber());\n\n                        if (tempSearchCriteria.equals(searchCriteria)) {\n                            return Constants.REPORTED_QUESTION_POSTS_CACHE_PREFIX + searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID) + Constants.UNDER_SCORE + searchCriteria.getPageNumber();\n                        }\n                    }\n                }\n\n                if (searchCriteria.getFilterCriteriaMap() != null\n                        && searchCriteria.getFilterCriteriaMap().containsKey(Constants.STATUS)\n                        && searchCriteria.getFilterCriteriaMap().containsKey(Constants.COMMUNITY_ID)\n                        && searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID) instanceof String) {\n                    SearchCriteria tempSearchCriteria = objectMapper.readValue(cbServerProperties.getMdoAnswerPostReportFeed(), SearchCriteria.class);\n                    if (tempSearchCriteria != null && tempSearchCriteria.getFilterCriteriaMap() != null) {\n                        tempSearchCriteria.getFilterCriteriaMap().put(Constants.COMMUNITY_ID, searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID));\n                        tempSearchCriteria.setPageNumber(searchCriteria.getPageNumber());\n\n                        if (tempSearchCriteria.equals(searchCriteria)) {\n                            return Constants.REPORTED_ANSWER_POST_POSTS_CACHE_PREFIX + searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID) + Constants.UNDER_SCORE + searchCriteria.getPageNumber();\n                        }\n                    }\n                }\n\n                if (searchCriteria.getFilterCriteriaMap() != null\n                        && searchCriteria.getFilterCriteriaMap().containsKey(Constants.STATUS)\n                        && searchCriteria.getFilterCriteriaMap().containsKey(Constants.COMMUNITY_ID)\n                        && searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID) instanceof String) {\n\n                    SearchCriteria tempSearchCriteria = objectMapper.readValue(cbServerProperties.getMdoAnswerPostReplyReportFeed(), SearchCriteria.class);\n                    if (tempSearchCriteria != null && tempSearchCriteria.getFilterCriteriaMap() != null) {\n                        tempSearchCriteria.getFilterCriteriaMap().put(Constants.COMMUNITY_ID, searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID));\n                        tempSearchCriteria.setPageNumber(searchCriteria.getPageNumber());\n\n                        if (tempSearchCriteria.equals(searchCriteria)) {\n                            return Constants.REPORTED_ANSWER_POST_REPLY_POSTS_CACHE_PREFIX + searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID) + Constants.UNDER_SCORE + searchCriteria.getPageNumber();\n                        }\n                    }\n                }\n\n                if (searchCriteria.getFilterCriteriaMap() != null\n                        && searchCriteria.getFilterCriteriaMap().containsKey(Constants.STATUS)\n                        && searchCriteria.getFilterCriteriaMap().containsKey(Constants.COMMUNITY_ID)\n                        && searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID) instanceof String) {\n\n                    SearchCriteria tempSearchCriteria = objectMapper.readValue(cbServerProperties.getMdoAllSuspendedFeed(), SearchCriteria.class);\n                    if (tempSearchCriteria != null && tempSearchCriteria.getFilterCriteriaMap() != null) {\n                        tempSearchCriteria.getFilterCriteriaMap().put(Constants.COMMUNITY_ID, searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID));\n                        tempSearchCriteria.setPageNumber(searchCriteria.getPageNumber());\n\n                        if (tempSearchCriteria.equals(searchCriteria)) {\n                            return Constants.SUSPENDED_POSTS_CACHE_PREFIX + searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID) + Constants.UNDER_SCORE + searchCriteria.getPageNumber();\n                        }\n                    }\n                }\n\n                String reqJsonString = objectMapper.writeValueAsString(searchCriteria);\n                return JWT.create().withClaim(Constants.REQUEST_PAYLOAD, reqJsonString).sign(Algorithm.HMAC256(Constants.JWT_SECRET_KEY));\n            } catch (JsonProcessingException e) {\n                log.error(\"Error occurred while converting json object to json string\", e);\n            }\n        }\n        return \"\";\n    }\n\n    @Override\n    public ApiResponse getEnrichedDiscussionData(Map<String, Object> data, String token) {\n        ApiResponse response = ProjectUtil.createDefaultResponse(\"discussion.getEnrichedDiscussionData\");\n        Map<String, Object> requestData = (Map<String, Object>) data.get(\"request\");\n\n        String userId = accessTokenValidator.verifyUserToken(token);\n        if (StringUtils.isBlank(userId) || userId.equals(Constants.UNAUTHORIZED)) {\n            response.getParams().setErrMsg(Constants.INVALID_AUTH_TOKEN);\n            response.setResponseCode(HttpStatus.BAD_REQUEST);\n            return response;\n        }\n\n        String errMsg = validateEnrichDataRequest(requestData);\n        if (StringUtils.isNotBlank(errMsg)) {\n            return ProjectUtil.returnErrorMsg(errMsg, HttpStatus.BAD_REQUEST, response, Constants.FAILED);\n        }\n\n        List<Map<String, Object>> communityFilters = (List<Map<String, Object>>) requestData.get(Constants.COMMUNITY_FILTERS);\n        List<String> filters = (List<String>) requestData.get(Constants.FILTERS);\n\n        List<String> allDiscussionIds = new ArrayList<>();\n        for (Map<String, Object> communityFilter : communityFilters) {\n            List<String> discussionIdsForCommunity = (List<String>) communityFilter.get(\"identifier\");\n            allDiscussionIds.addAll(discussionIdsForCommunity);\n        }\n\n        Map<String, Boolean> likesMap = initializeDefaultMap(allDiscussionIds, false);\n        Map<String, Boolean> bookmarksMap = initializeDefaultMap(allDiscussionIds, false);\n        Map<String, Boolean> reportedMap = initializeDefaultMap(allDiscussionIds, false);\n\n        try {\n            for (Map<String, Object> communityFilter : communityFilters) {\n                String communityId = (String) communityFilter.get(Constants.COMMUNITY_ID);\n                List<String> discussionIds = (List<String>) communityFilter.get(Constants.IDENTIFIER);\n\n                if (filters.contains(Constants.LIKES)) {\n                    fetchLikes(discussionIds, userId, likesMap);\n                }\n                if (filters.contains(Constants.BOOKMARKS)) {\n                    fetchBookmarks(discussionIds, userId, communityId, bookmarksMap);\n                }\n                if (filters.contains(Constants.REPORTED)) {\n                    fetchReported(discussionIds, userId, reportedMap);\n                }\n            }\n\n            Map<String, Object> searchResults = new HashMap<>();\n            searchResults.put(Constants.LIKES, likesMap);\n            searchResults.put(Constants.BOOKMARKS, bookmarksMap);\n            searchResults.put(Constants.REPORTED, reportedMap);\n            response.setResult(Collections.singletonMap(Constants.SEARCH_RESULTS, searchResults));\n\n        } catch (Exception e) {\n            log.error(\"DiscussionService::getEnrichedDiscussionData: Failed to fetch discussions\", e);\n            return ProjectUtil.returnErrorMsg(\"getEnrichedDiscussionData\", HttpStatus.INTERNAL_SERVER_ERROR, response, Constants.FAILED);\n        }\n        return response;\n    }\n\n    private Map<String, Boolean> initializeDefaultMap(List<String> discussionIds, boolean defaultValue) {\n        Map<String, Boolean> defaultMap = new HashMap<>();\n        for (String discussionId : discussionIds) {\n            defaultMap.put(discussionId, defaultValue);\n        }\n        return defaultMap;\n    }\n\n    private void fetchLikes(List<String> discussionIds, String userId, Map<String, Boolean> likesMap) {\n        Map<String, Object> properties = new HashMap<>();\n        properties.put(Constants.DISCUSSION_ID_KEY, discussionIds);\n        properties.put(Constants.USERID, userId);\n\n        List<Map<String, Object>> likesList = cassandraOperation.getRecordsByPropertiesWithoutFiltering(\n                Constants.KEYSPACE_SUNBIRD, Constants.USER_POST_VOTES, properties, null, null);\n\n        likesList.stream()\n                .filter(record -> Boolean.TRUE.equals(record.get(Constants.VOTE_TYPE)))\n                .map(record -> (String) record.get(Constants.DISCUSSION_ID_KEY))\n                .forEach(discussionId -> likesMap.put(discussionId, true));\n    }\n\n    private void fetchBookmarks(List<String> discussionIds, String userId, String communityId, Map<String, Boolean> bookmarksMap) {\n\n        Map<String, Object> properties = new HashMap<>();\n        properties.put(Constants.DISCUSSION_ID_KEY, discussionIds);\n        properties.put(Constants.USERID, userId);\n        properties.put(Constants.COMMUNITY_ID, communityId);\n\n        List<Map<String, Object>> bookmarksList = cassandraOperation.getRecordsByPropertiesWithoutFiltering(\n                Constants.KEYSPACE_SUNBIRD, Constants.DISCUSSION_BOOKMARKS, properties, null, null);\n\n        bookmarksList.stream()\n                .filter(record -> Boolean.TRUE.equals(record.get(Constants.STATUS)))\n                .map(record -> (String) record.get(Constants.DISCUSSION_ID_KEY))\n                .forEach(discussionId -> bookmarksMap.put(discussionId, true));\n    }\n\n    private void fetchReported(List<String> discussionIds, String userId, Map<String, Boolean> reportedMap) {\n        Map<String, Object> properties = new HashMap<>();\n        properties.put(Constants.DISCUSSION_ID_KEY, discussionIds);\n        properties.put(Constants.USERID, userId);\n\n        List<Map<String, Object>> reportedList = cassandraOperation.getRecordsByPropertiesWithoutFiltering(\n                Constants.KEYSPACE_SUNBIRD, Constants.DISCUSSION_POST_REPORT_LOOKUP_BY_USER, properties, null, null);\n\n        reportedList.stream()\n                .map(record -> (String) record.get(Constants.DISCUSSION_ID_KEY))\n                .forEach(discussionId -> reportedMap.put(discussionId, true));\n    }\n\n    private String validateEnrichDataRequest(Map<String, Object> requestData) {\n        if (requestData == null) {\n            return Constants.MISSING_REQUEST_DATA;\n        }\n\n        List<String> errList = new ArrayList<>();\n\n        Object communityFiltersObj = requestData.get(Constants.COMMUNITY_FILTERS);\n        if (!(communityFiltersObj instanceof List<?>)) {\n            errList.add(\"Missing or invalid communityFilters.\");\n        } else {\n            List<?> communityFilters = (List<?>) communityFiltersObj;\n            if (communityFilters.isEmpty()) {\n                errList.add(\"Empty communityFilters.\");\n            } else {\n                for (Object obj : communityFilters) {\n                    if (!(obj instanceof Map<?, ?>)) {\n                        errList.add(\"Invalid communityFilters structure.\");\n                        continue;\n                    }\n\n                    Map<?, ?> communityFilter = (Map<?, ?>) obj;\n\n                    String communityId = (String) communityFilter.get(Constants.COMMUNITY_ID);\n                    List<?> identifiers = (List<?>) communityFilter.get(Constants.IDENTIFIER);\n\n                    if (StringUtils.isBlank(communityId) || identifiers == null || identifiers.isEmpty()) {\n                        errList.add(\"Invalid communityFilter: communityId or identifiers are missing/empty.\");\n                    }\n                }\n            }\n        }\n\n        List<String> validFilters = Arrays.asList(Constants.LIKES, Constants.BOOKMARKS, Constants.REPORTED);\n        if (!requestData.containsKey(Constants.FILTERS) ||\n                !(requestData.get(Constants.FILTERS) instanceof List)) {\n            errList.add(Constants.FILTERS);\n        } else {\n            List<?> filtersList = (List<?>) requestData.get(Constants.FILTERS);\n            if (filtersList.isEmpty() || filtersList.stream().noneMatch(validFilters::contains)) {\n                errList.add(Constants.FILTERS);\n            }\n        }\n        return errList.isEmpty() ? \"\" : \"Failed Due To Missing or Invalid Params - \" + errList + \".\";\n    }\n\n    @Override\n    public ApiResponse getGlobalFeed(SearchCriteria searchCriteria, String token, boolean isOverride) {\n        ApiResponse response = ProjectUtil.createDefaultResponse(Constants.DISCUSSION_GET_GLOBAL_FEED_API);\n        String userId = accessTokenValidator.verifyUserToken(token);\n\n        if (StringUtils.isBlank(userId) || Constants.UNAUTHORIZED.equals(userId)) {\n            return ProjectUtil.returnErrorMsg(Constants.INVALID_AUTH_TOKEN, HttpStatus.UNAUTHORIZED, response, Constants.FAILED);\n        }\n        return getGlobalFeedUsingUserId(searchCriteria, userId, isOverride);\n    }\n\n    private ApiResponse getGlobalFeedUsingUserId(SearchCriteria searchCriteria, String userId, boolean isOverride) {\n        ApiResponse response = ProjectUtil.createDefaultResponse(Constants.DISCUSSION_GET_GLOBAL_FEED_API);\n\n        if (StringUtils.isBlank(userId) || Constants.UNAUTHORIZED.equals(userId)) {\n            return ProjectUtil.returnErrorMsg(Constants.INVALID_AUTH_TOKEN, HttpStatus.UNAUTHORIZED, response, Constants.FAILED);\n        }\n\n        populateCommunityIds(userId, searchCriteria);\n        if (CollectionUtils.isEmpty((Set<String>) searchCriteria.getFilterCriteriaMap().get(Constants.COMMUNITY_ID))) {\n            return ProjectUtil.returnErrorMsg(Constants.NO_COMMUNITY_FOUND, HttpStatus.OK, response, Constants.SUCCESS);\n        }\n        response = searchDiscussion(searchCriteria, isOverride);\n        return response;\n    }\n\n    private void populateCommunityIds(String userId, SearchCriteria searchCriteria) {\n        Map<String, Object> propertyMap = new HashMap<>();\n        propertyMap.put(Constants.USERID, userId);\n        List<Map<String, Object>> communitiesData = cassandraOperation.getRecordsByPropertiesWithoutFiltering(\n                Constants.KEYSPACE_SUNBIRD, Constants.USER_COMMUNITY, propertyMap, Arrays.asList(Constants.COMMUNITY_ID_KEY, Constants.STATUS), null);\n        if (!CollectionUtils.isEmpty(communitiesData)) {\n            Set<String> communityIds = communitiesData.stream()\n                    .filter(community -> (boolean) community.get(Constants.STATUS))\n                    .map(community -> (String) community.get(Constants.COMMUNITY_ID_KEY))\n                    .collect(Collectors.toSet());\n\n            if (!CollectionUtils.isEmpty(communityIds)) {\n                searchCriteria.getFilterCriteriaMap().put(Constants.COMMUNITY_ID, communityIds);\n            }\n        }\n    }\n\n    private boolean isTrendingPost(SearchCriteria searchCriteria) {\n        try {\n            SearchCriteria trendingCriteria = objectMapper.readValue(cbServerProperties.getFilterCriteriaTrendingFeed(), SearchCriteria.class);\n            trendingCriteria.setPageNumber(searchCriteria.getPageNumber());\n            return searchCriteria.equals(trendingCriteria);\n        } catch (Exception e) {\n            log.error(\"Error occurred while checking if the post is trending\", e);\n            return false;\n        }\n    }\n\n    private void enhanceCommunityData(List<Map<String, Object>> discussions) {\n        Set<String> communityIds = discussions.stream()\n                .map(discussion -> (String) discussion.get(Constants.COMMUNITY_ID))\n                .collect(Collectors.toSet());\n\n        // Fetch community data from Redis\n        List<Object> redisResults = fetchDataForKeys(\n                communityIds.stream().map(id -> Constants.COMMUNITY_PREFIX + id).collect(Collectors.toList()), false\n        );\n\n        Map<String, String> communityDetailsMap = redisResults.stream()\n                .map(community -> (Map<String, Object>) community)\n                .collect(Collectors.toMap(\n                        community -> community.get(Constants.COMMUNITY_ID).toString(),\n                        community -> (String) community.get(Constants.COMMUNITY_NAME)\n                ));\n\n        // Identify missing communityIds\n        List<String> missingCommunityIds = communityIds.stream()\n                .filter(id -> !communityDetailsMap.containsKey(id))\n                .collect(Collectors.toList());\n\n        // Fetch missing community data from PostgreSQL\n        if (!missingCommunityIds.isEmpty()) {\n            List<Object> postgresResults = fetchCommunityFromPrimary(missingCommunityIds);\n            for (Object community : postgresResults) {\n                Map<String, Object> communityMap = (Map<String, Object>) community;\n                communityDetailsMap.put(\n                        communityMap.get(Constants.COMMUNITY_ID_KEY).toString(),\n                        (String) communityMap.get(Constants.COMMUNITY_NAME)\n                );\n            }\n        }\n\n        // Enhance discussions with community data\n        discussions.forEach(discussion -> {\n            String communityId = (String) discussion.get(Constants.COMMUNITY_ID);\n            if (communityDetailsMap.containsKey(communityId)) {\n                discussion.put(Constants.COMMUNITY_NAME, communityDetailsMap.get(communityId));\n            }\n        });\n    }\n\n    private List<Object> fetchCommunityFromPrimary(List<String> communityIds) {\n        log.info(\"Fetching community data from PostgreSQL\");\n        List<Object> communityList = new ArrayList<>();\n        long startTime = System.currentTimeMillis();\n\n        List<CommunityEntity> communityEntities = communityEngagementRepository.findAllById(communityIds);\n        updateMetricsDbOperation(Constants.DISCUSSION_SEARCH, Constants.POSTGRES, Constants.READ, startTime);\n\n        communityList = communityEntities.stream()\n                .map(communityEntity -> {\n                    Map<String, Object> communityMap = new HashMap<>();\n                    communityMap.put(Constants.COMMUNITY_ID_KEY, communityEntity.getCommunityId());\n                    communityMap.put(Constants.COMMUNITY_NAME, communityEntity.getData().get(Constants.COMMUNITY_NAME).asText());\n                    return communityMap;\n                })\n                .collect(Collectors.toList());\n        return communityList;\n    }\n\n    private List<String> getTrendingPosts() {\n        SearchCriteria searchCriteria = new SearchCriteria();\n        searchCriteria.setFilterCriteriaMap(new HashMap<>());\n        searchCriteria.setRequestedFields(Arrays.asList(Constants.COMMUNITY_ID));\n        searchCriteria.getFilterCriteriaMap().put(Constants.STATUS, Constants.ACTIVE);\n        searchCriteria.setOrderBy(Constants.COUNT_OF_ANSWER_POST_COUNT);\n        searchCriteria.setOrderDirection(Constants.DESC);\n        searchCriteria.setPageNumber(0);\n        searchCriteria.setPageSize(10);\n        SearchResult result = null;\n        List<String> communityIds = new ArrayList<>();\n        try {\n            result = esUtilService.searchDocuments(cbServerProperties.getCommunityEntity(), searchCriteria, cbServerProperties.getElasticCommunityJsonPath());\n\n            if (CollectionUtils.isNotEmpty(result.getData())) {\n                List<Map<String, Object>> communities = result.getData();\n                for (Map<String, Object> community : communities) {\n                    communityIds.add((String) community.get(Constants.COMMUNITY_ID));\n                }\n            }\n        } catch (Exception e) {\n            log.error(\"Error occurred while fetching trending communities\", e);\n        }\n        return communityIds;\n    }\n\n    private SearchCriteria createDefaultSearchCriteria(String parentAnswerPostId,\n                                                       String communityId) {\n        SearchCriteria criteria = new SearchCriteria();\n        HashMap<String, Object> filterMap = new HashMap<>();\n        filterMap.put(Constants.COMMUNITY_ID, communityId);\n        filterMap.put(Constants.TYPE, Constants.ANSWER_POST_REPLY);\n        filterMap.put(Constants.PARENT_ANSWER_POST_ID, parentAnswerPostId);\n        criteria.setFilterCriteriaMap(filterMap);\n        criteria.setRequestedFields(Collections.emptyList());\n        criteria.setPageNumber(0);\n        criteria.setPageSize(10);\n        criteria.setOrderBy(Constants.CREATED_ON);\n        criteria.setOrderDirection(Constants.DESC);\n        criteria.setFacets(Collections.emptyList());\n        return criteria;\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/igot/cb/discussion/service/impl/DiscussionServiceImpl.java b/src/main/java/com/igot/cb/discussion/service/impl/DiscussionServiceImpl.java
--- a/src/main/java/com/igot/cb/discussion/service/impl/DiscussionServiceImpl.java	(revision 6f4470fe2ef7499981fac434a4e27e1eb28f81fa)
+++ b/src/main/java/com/igot/cb/discussion/service/impl/DiscussionServiceImpl.java	(date 1749404525537)
@@ -561,7 +561,7 @@
                     communityObject.put(Constants.COMMUNITY_ID, dataNode.get(Constants.COMMUNITY_ID).asText());
                     communityObject.put(Constants.STATUS, Constants.INCREMENT);
                     communityObject.put(Constants.DISCUSSION_ID, discussionId);
-                    producer.push(cbServerProperties.getCommunityLikeCount(), communityObject);
+//                    producer.push(cbServerProperties.getCommunityLikeCount(), communityObject);
                 } else {
                     DiscussionServiceUtil.createErrorResponse(response, Constants.USER_MUST_VOTE_FIRST, HttpStatus.BAD_REQUEST, Constants.FAILED);
                     return response;
@@ -589,7 +589,7 @@
                 communityObject.put(Constants.COMMUNITY_ID, dataNode.get(Constants.COMMUNITY_ID).asText());
                 communityObject.put(Constants.DISCUSSION_ID, discussionId);
                 communityObject.put(Constants.STATUS, Constants.UP.equals(voteType) ? Constants.INCREMENT : Constants.DECREMENT);
-                producer.push(cbServerProperties.getCommunityLikeCount(), communityObject);
+//                producer.push(cbServerProperties.getCommunityLikeCount(), communityObject);
             }
 
             discussionData.put(Constants.UP_VOTE_COUNT, currentVote ? existingUpVoteCount + 1 : existingUpVoteCount - 1);
@@ -622,6 +622,7 @@
 
             String firstName = helperMethodService.fetchUserFirstName(createdBy);
 
+            log.info("Notification trigger started");
             if (!userId.equals(createdBy)) {
                 if (type.equalsIgnoreCase(Constants.QUESTION)) {
                     notificationTriggerService.triggerNotification(LIKED_POST, List.of(createdBy), TITLE, firstName, data);
