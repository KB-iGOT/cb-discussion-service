<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Base64Util.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">cb-discussion-service</a> &gt; <a href="index.source.html" class="el_package">com.igot.cb.authentication.util</a> &gt; <span class="el_source">Base64Util.java</span></div><h1>Base64Util.java</h1><pre class="source lang-java linenums">package com.igot.cb.authentication.util;

/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.io.UnsupportedEncodingException;

/**
 * Utilities for encoding and decoding the Base64 representation of
 * binary data.  See RFCs &lt;a
 * href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;2045&lt;/a&gt; and &lt;a
 * href=&quot;http://www.ietf.org/rfc/rfc3548.txt&quot;&gt;3548&lt;/a&gt;.
 */
<span class="fc" id="L26">public class Base64Util {</span>
    /**
     * Default values for encoder/decoder flags.
     */
    public static final int DEFAULT = 0;

    /**
     * Encoder flag bit to omit the padding '=' characters at the end
     * of the output (if any).
     */
    public static final int NO_PADDING = 1;

    /**
     * Encoder flag bit to omit all line terminators (i.e., the output
     * will be on one long line).
     */
    public static final int NO_WRAP = 2;

    /**
     * Encoder flag bit to indicate lines should be terminated with a
     * CRLF pair instead of just an LF.  Has no effect if {@code
     * NO_WRAP} is specified as well.
     */
    public static final int CRLF = 4;

    /**
     * Encoder/decoder flag bit to indicate using the &quot;URL and
     * filename safe&quot; variant of Base64 (see RFC 3548 section 4) where
     * {@code -} and {@code _} are used in place of {@code +} and
     * {@code /}.
     */
    public static final int URL_SAFE = 8;

    /**
     * Flag to pass to {Base64OutputStream} to indicate that it
     * should not close the output stream it is wrapping when it
     * itself is closed.
     */
    public static final int NO_CLOSE = 16;

    //  --------------------------------------------------------
    //  shared code
    //  --------------------------------------------------------

    private Base64Util() {
    }   // don't instantiate

    //  --------------------------------------------------------
    //  decoding
    //  --------------------------------------------------------

    /**
     * Decode the Base64-encoded data in input and return the data in
     * a new byte array.
     * &lt;p&gt;
     * &lt;p&gt;The padding '=' characters at the end are considered optional, but
     * if any are present, there must be the correct number of them.
     *
     * @param str   the input String to decode, which is converted to
     *              bytes using the default charset
     * @param flags controls certain features of the decoded output.
     *              Pass {@code DEFAULT} to decode standard Base64.
     * @throws IllegalArgumentException if the input contains
     *                                  incorrect padding
     */
    public static byte[] decode(String str, int flags) {
<span class="fc" id="L92">        return decode(str.getBytes(), flags);</span>
    }

    /**
     * Decode the Base64-encoded data in input and return the data in
     * a new byte array.
     * &lt;p&gt;
     * &lt;p&gt;The padding '=' characters at the end are considered optional, but
     * if any are present, there must be the correct number of them.
     *
     * @param input the input array to decode
     * @param flags controls certain features of the decoded output.
     *              Pass {@code DEFAULT} to decode standard Base64.
     * @throws IllegalArgumentException if the input contains
     *                                  incorrect padding
     */
    public static byte[] decode(byte[] input, int flags) {
<span class="fc" id="L109">        return decode(input, 0, input.length, flags);</span>
    }

    /**
     * Decode the Base64-encoded data in input and return the data in
     * a new byte array.
     * &lt;p&gt;
     * &lt;p&gt;The padding '=' characters at the end are considered optional, but
     * if any are present, there must be the correct number of them.
     *
     * @param input  the data to decode
     * @param offset the position within the input array at which to start
     * @param len    the number of bytes of input to decode
     * @param flags  controls certain features of the decoded output.
     *               Pass {@code DEFAULT} to decode standard Base64.
     * @throws IllegalArgumentException if the input contains
     *                                  incorrect padding
     */
    public static byte[] decode(byte[] input, int offset, int len, int flags) {
        // Allocate space for the most data the input could represent.
        // (It could contain less if it contains whitespace, etc.)
<span class="fc" id="L130">        Decoder decoder = new Decoder(flags, new byte[len * 3 / 4]);</span>

<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (!decoder.process(input, offset, len, true)) {</span>
<span class="fc" id="L133">            throw new IllegalArgumentException(&quot;bad base-64&quot;);</span>
        }

        // Maybe we got lucky and allocated exactly enough output space.
<span class="fc bfc" id="L137" title="All 2 branches covered.">        if (decoder.op == decoder.output.length) {</span>
<span class="fc" id="L138">            return decoder.output;</span>
        }

        // Need to shorten the array, so allocate a new one of the
        // right size and copy.
<span class="fc" id="L143">        byte[] temp = new byte[decoder.op];</span>
<span class="fc" id="L144">        System.arraycopy(decoder.output, 0, temp, 0, decoder.op);</span>
<span class="fc" id="L145">        return temp;</span>
    }

    /**
     * Base64-encode the given data and return a newly allocated
     * String with the result.
     *
     * @param input the data to encode
     * @param flags controls certain features of the encoded output.
     *              Passing {@code DEFAULT} results in output that
     *              adheres to RFC 2045.
     */
    public static String encodeToString(byte[] input, int flags) {
        try {
<span class="nc" id="L159">            return new String(encode(input, flags), &quot;US-ASCII&quot;);</span>
<span class="nc" id="L160">        } catch (UnsupportedEncodingException e) {</span>
            // US-ASCII is guaranteed to be available.
<span class="nc" id="L162">            throw new AssertionError(e);</span>
        }
    }

    //  --------------------------------------------------------
    //  encoding
    //  --------------------------------------------------------

    /**
     * Base64-encode the given data and return a newly allocated
     * String with the result.
     *
     * @param input  the data to encode
     * @param offset the position within the input array at which to
     *               start
     * @param len    the number of bytes of input to encode
     * @param flags  controls certain features of the encoded output.
     *               Passing {@code DEFAULT} results in output that
     *               adheres to RFC 2045.
     */
    public static String encodeToString(byte[] input, int offset, int len, int flags) {
        try {
<span class="nc" id="L184">            return new String(encode(input, offset, len, flags), &quot;US-ASCII&quot;);</span>
<span class="nc" id="L185">        } catch (UnsupportedEncodingException e) {</span>
            // US-ASCII is guaranteed to be available.
<span class="nc" id="L187">            throw new AssertionError(e);</span>
        }
    }

    /**
     * Base64-encode the given data and return a newly allocated
     * byte[] with the result.
     *
     * @param input the data to encode
     * @param flags controls certain features of the encoded output.
     *              Passing {@code DEFAULT} results in output that
     *              adheres to RFC 2045.
     */
    public static byte[] encode(byte[] input, int flags) {
<span class="fc" id="L201">        return encode(input, 0, input.length, flags);</span>
    }

    /**
     * Base64-encode the given data and return a newly allocated
     * byte[] with the result.
     *
     * @param input  the data to encode
     * @param offset the position within the input array at which to
     *               start
     * @param len    the number of bytes of input to encode
     * @param flags  controls certain features of the encoded output.
     *               Passing {@code DEFAULT} results in output that
     *               adheres to RFC 2045.
     */
    public static byte[] encode(byte[] input, int offset, int len, int flags) {
<span class="fc" id="L217">        Encoder encoder = new Encoder(flags, null);</span>

        // Compute the exact length of the array we will produce.
<span class="fc" id="L220">        int output_len = len / 3 * 4;</span>

        // Account for the tail of the data and the padding bytes, if any.
<span class="fc bfc" id="L223" title="All 2 branches covered.">        if (encoder.do_padding) {</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">            if (len % 3 &gt; 0) {</span>
<span class="fc" id="L225">                output_len += 4;</span>
            }
        } else {
<span class="pc bpc" id="L228" title="3 of 4 branches missed.">            switch (len % 3) {</span>
                case 0:
<span class="nc" id="L230">                    break;</span>
                case 1:
<span class="fc" id="L232">                    output_len += 2;</span>
<span class="fc" id="L233">                    break;</span>
                case 2:
<span class="nc" id="L235">                    output_len += 3;</span>
                    break;
            }
        }

        // Account for the newlines, if any.
<span class="fc bfc" id="L241" title="All 4 branches covered.">        if (encoder.do_newline &amp;&amp; len &gt; 0) {</span>
<span class="fc" id="L242">            output_len += (((len - 1) / (3 * Encoder.LINE_GROUPS)) + 1) *</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">                    (encoder.do_cr ? 2 : 1);</span>
        }

<span class="fc" id="L246">        encoder.output = new byte[output_len];</span>
<span class="fc" id="L247">        encoder.process(input, offset, len, true);</span>

<span class="pc bpc" id="L249" title="1 of 2 branches missed.">        assert encoder.op == output_len;</span>

<span class="fc" id="L251">        return encoder.output;</span>
    }

<span class="fc" id="L254">    /* package */ static abstract class Coder {</span>
        public byte[] output;
        public int op;

        /**
         * Encode/decode another block of input data.  this.output is
         * provided by the caller, and must be big enough to hold all
         * the coded data.  On exit, this.opwill be set to the length
         * of the coded data.
         *
         * @param finish true if this is the final call to process for
         *               this object.  Will finalize the coder state and
         *               include any final bytes in the output.
         * @return true if the input so far is good; false if some
         * error has been detected in the input stream..
         */
        public abstract boolean process(byte[] input, int offset, int len, boolean finish);

        /**
         * @return the maximum number of bytes a call to process()
         * could produce for the given number of input bytes.  This may
         * be an overestimate.
         */
        public abstract int maxOutputSize(int len);
    }

    /* package */ static class Decoder extends Coder {
        /**
         * Lookup table for turning bytes into their position in the
         * Base64 alphabet.
         */
<span class="fc" id="L285">        private static final int DECODE[] = {</span>
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
                -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        };

        /**
         * Decode lookup table for the &quot;web safe&quot; variant (RFC 3548
         * sec. 4) where - and _ replace + and /.
         */
<span class="fc" id="L308">        private static final int DECODE_WEBSAFE[] = {</span>
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,
                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
                -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,
                -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        };

        /**
         * Non-data values in the DECODE arrays.
         */
        private static final int SKIP = -1;
        private static final int EQUALS = -2;
        final private int[] alphabet;
        /**
         * States 0-3 are reading through the next input tuple.
         * State 4 is having read one '=' and expecting exactly
         * one more.
         * State 5 is expecting no more data or padding characters
         * in the input.
         * State 6 is the error state; an error has been detected
         * in the input and no future input can &quot;fix&quot; it.
         */
        private int state;   // state number (0 to 6)
        private int value;

<span class="fc" id="L345">        public Decoder(int flags, byte[] output) {</span>
<span class="fc" id="L346">            this.output = output;</span>

<span class="fc bfc" id="L348" title="All 2 branches covered.">            alphabet = ((flags &amp; URL_SAFE) == 0) ? DECODE : DECODE_WEBSAFE;</span>
<span class="fc" id="L349">            state = 0;</span>
<span class="fc" id="L350">            value = 0;</span>
<span class="fc" id="L351">        }</span>

        /**
         * @return an overestimate for the number of bytes {@code
         * len} bytes could decode to.
         */
        public int maxOutputSize(int len) {
<span class="nc" id="L358">            return len * 3 / 4 + 10;</span>
        }

        /**
         * Decode another block of input data.
         *
         * @return true if the state machine is still healthy.  false if
         * bad base-64 data has been detected in the input stream.
         */
        public boolean process(byte[] input, int offset, int len, boolean finish) {
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">            if (this.state == 6) return false;</span>

<span class="fc" id="L370">            int p = offset;</span>
<span class="fc" id="L371">            len += offset;</span>

            // Using local variables makes the decoder about 12%
            // faster than if we manipulate the member variables in
            // the loop.  (Even alphabet makes a measurable
            // difference, which is somewhat surprising to me since
            // the member variable is final.)
<span class="fc" id="L378">            int state = this.state;</span>
<span class="fc" id="L379">            int value = this.value;</span>
<span class="fc" id="L380">            int op = 0;</span>
<span class="fc" id="L381">            final byte[] output = this.output;</span>
<span class="fc" id="L382">            final int[] alphabet = this.alphabet;</span>

<span class="fc bfc" id="L384" title="All 2 branches covered.">            while (p &lt; len) {</span>
                // Try the fast path:  we're starting a new tuple and the
                // next four bytes of the input stream are all data
                // bytes.  This corresponds to going through states
                // 0-1-2-3-0.  We expect to use this method for most of
                // the data.
                //
                // If any of the next four bytes of input are non-data
                // (whitespace, etc.), value will end up negative.  (All
                // the non-data values in decode are small negative
                // numbers, so shifting any of them up and or'ing them
                // together will result in a value with its top bit set.)
                //
                // You can remove this whole block and the output should
                // be the same, just slower.
<span class="fc bfc" id="L399" title="All 2 branches covered.">                if (state == 0) {</span>
<span class="fc bfc" id="L400" title="All 4 branches covered.">                    while (p + 4 &lt;= len &amp;&amp;</span>
                            (value = ((alphabet[input[p] &amp; 0xff] &lt;&lt; 18) |
                                    (alphabet[input[p + 1] &amp; 0xff] &lt;&lt; 12) |
                                    (alphabet[input[p + 2] &amp; 0xff] &lt;&lt; 6) |
                                    (alphabet[input[p + 3] &amp; 0xff]))) &gt;= 0) {
<span class="fc" id="L405">                        output[op + 2] = (byte) value;</span>
<span class="fc" id="L406">                        output[op + 1] = (byte) (value &gt;&gt; 8);</span>
<span class="fc" id="L407">                        output[op] = (byte) (value &gt;&gt; 16);</span>
<span class="fc" id="L408">                        op += 3;</span>
<span class="fc" id="L409">                        p += 4;</span>
                    }
<span class="fc bfc" id="L411" title="All 2 branches covered.">                    if (p &gt;= len) break;</span>
                }

                // The fast path isn't available -- either we've read a
                // partial tuple, or the next four input bytes aren't all
                // data, or whatever.  Fall back to the slower state
                // machine implementation.

<span class="fc" id="L419">                int d = alphabet[input[p++] &amp; 0xff];</span>

<span class="pc bpc" id="L421" title="2 of 7 branches missed.">                switch (state) {</span>
                    case 0:
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">                        if (d &gt;= 0) {</span>
<span class="fc" id="L424">                            value = d;</span>
<span class="fc" id="L425">                            ++state;</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">                        } else if (d != SKIP) {</span>
<span class="nc" id="L427">                            this.state = 6;</span>
<span class="nc" id="L428">                            return false;</span>
                        }
                        break;

                    case 1:
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">                        if (d &gt;= 0) {</span>
<span class="fc" id="L434">                            value = (value &lt;&lt; 6) | d;</span>
<span class="fc" id="L435">                            ++state;</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">                        } else if (d != SKIP) {</span>
<span class="nc" id="L437">                            this.state = 6;</span>
<span class="nc" id="L438">                            return false;</span>
                        }
                        break;

                    case 2:
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">                        if (d &gt;= 0) {</span>
<span class="fc" id="L444">                            value = (value &lt;&lt; 6) | d;</span>
<span class="fc" id="L445">                            ++state;</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">                        } else if (d == EQUALS) {</span>
                            // Emit the last (partial) output tuple;
                            // expect exactly one more padding character.
<span class="nc" id="L449">                            output[op++] = (byte) (value &gt;&gt; 4);</span>
<span class="nc" id="L450">                            state = 4;</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">                        } else if (d != SKIP) {</span>
<span class="nc" id="L452">                            this.state = 6;</span>
<span class="nc" id="L453">                            return false;</span>
                        }
                        break;

                    case 3:
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">                        if (d &gt;= 0) {</span>
                            // Emit the output triple and return to state 0.
<span class="nc" id="L460">                            value = (value &lt;&lt; 6) | d;</span>
<span class="nc" id="L461">                            output[op + 2] = (byte) value;</span>
<span class="nc" id="L462">                            output[op + 1] = (byte) (value &gt;&gt; 8);</span>
<span class="nc" id="L463">                            output[op] = (byte) (value &gt;&gt; 16);</span>
<span class="nc" id="L464">                            op += 3;</span>
<span class="nc" id="L465">                            state = 0;</span>
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">                        } else if (d == EQUALS) {</span>
                            // Emit the last (partial) output tuple;
                            // expect no further data or padding characters.
<span class="fc" id="L469">                            output[op + 1] = (byte) (value &gt;&gt; 2);</span>
<span class="fc" id="L470">                            output[op] = (byte) (value &gt;&gt; 10);</span>
<span class="fc" id="L471">                            op += 2;</span>
<span class="fc" id="L472">                            state = 5;</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">                        } else if (d != SKIP) {</span>
<span class="nc" id="L474">                            this.state = 6;</span>
<span class="nc" id="L475">                            return false;</span>
                        }
                        break;

                    case 4:
<span class="nc bnc" id="L480" title="All 2 branches missed.">                        if (d == EQUALS) {</span>
<span class="nc" id="L481">                            ++state;</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">                        } else if (d != SKIP) {</span>
<span class="nc" id="L483">                            this.state = 6;</span>
<span class="nc" id="L484">                            return false;</span>
                        }
                        break;

                    case 5:
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">                        if (d != SKIP) {</span>
<span class="fc" id="L490">                            this.state = 6;</span>
<span class="fc" id="L491">                            return false;</span>
                        }
                        break;
                }
<span class="fc" id="L495">            }</span>

<span class="pc bpc" id="L497" title="1 of 2 branches missed.">            if (!finish) {</span>
                // We're out of input, but a future call could provide
                // more.
<span class="nc" id="L500">                this.state = state;</span>
<span class="nc" id="L501">                this.value = value;</span>
<span class="nc" id="L502">                this.op = op;</span>
<span class="nc" id="L503">                return true;</span>
            }

            // Done reading input.  Now figure out where we are left in
            // the state machine and finish up.

<span class="pc bpc" id="L509" title="3 of 6 branches missed.">            switch (state) {</span>
                case 0:
                    // Output length is a multiple of three.  Fine.
<span class="fc" id="L512">                    break;</span>
                case 1:
                    // Read one extra input byte, which isn't enough to
                    // make another output byte.  Illegal.
<span class="fc" id="L516">                    this.state = 6;</span>
<span class="fc" id="L517">                    return false;</span>
                case 2:
                    // Read two extra input bytes, enough to emit 1 more
                    // output byte.  Fine.
<span class="nc" id="L521">                    output[op++] = (byte) (value &gt;&gt; 4);</span>
<span class="nc" id="L522">                    break;</span>
                case 3:
                    // Read three extra input bytes, enough to emit 2 more
                    // output bytes.  Fine.
<span class="nc" id="L526">                    output[op++] = (byte) (value &gt;&gt; 10);</span>
<span class="nc" id="L527">                    output[op++] = (byte) (value &gt;&gt; 2);</span>
<span class="nc" id="L528">                    break;</span>
                case 4:
                    // Read one padding '=' when we expected 2.  Illegal.
<span class="nc" id="L531">                    this.state = 6;</span>
<span class="nc" id="L532">                    return false;</span>
                case 5:
                    // Read all the padding '='s we expected and no more.
                    // Fine.
                    break;
            }

<span class="fc" id="L539">            this.state = state;</span>
<span class="fc" id="L540">            this.op = op;</span>
<span class="fc" id="L541">            return true;</span>
        }
    }

    /* package */ static class Encoder extends Coder {
        /**
         * Emit a new line every this many output tuples.  Corresponds to
         * a 76-character line length (the maximum allowable according to
         * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045&lt;/a&gt;).
         */
        public static final int LINE_GROUPS = 19;

        /**
         * Lookup table for turning Base64 alphabet positions (6 bits)
         * into output bytes.
         */
<span class="fc" id="L557">        private static final byte ENCODE[] = {</span>
                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
        };

        /**
         * Lookup table for turning Base64 alphabet positions (6 bits)
         * into output bytes.
         */
<span class="fc" id="L568">        private static final byte ENCODE_WEBSAFE[] = {</span>
                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
                'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
                'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
                'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_',
        };
        final public boolean do_padding;
        final public boolean do_newline;
        final public boolean do_cr;
        final private byte[] tail;
        final private byte[] alphabet;
        /* package */ int tailLen;
        private int count;

<span class="fc" id="L582">        public Encoder(int flags, byte[] output) {</span>
<span class="fc" id="L583">            this.output = output;</span>

<span class="fc bfc" id="L585" title="All 2 branches covered.">            do_padding = (flags &amp; NO_PADDING) == 0;</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">            do_newline = (flags &amp; NO_WRAP) == 0;</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">            do_cr = (flags &amp; CRLF) != 0;</span>
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">            alphabet = ((flags &amp; URL_SAFE) == 0) ? ENCODE : ENCODE_WEBSAFE;</span>

<span class="fc" id="L590">            tail = new byte[2];</span>
<span class="fc" id="L591">            tailLen = 0;</span>

<span class="fc bfc" id="L593" title="All 2 branches covered.">            count = do_newline ? LINE_GROUPS : -1;</span>
<span class="fc" id="L594">        }</span>

        /**
         * @return an overestimate for the number of bytes {@code
         * len} bytes could encode to.
         */
        public int maxOutputSize(int len) {
<span class="nc" id="L601">            return len * 8 / 5 + 10;</span>
        }

        public boolean process(byte[] input, int offset, int len, boolean finish) {
            // Using local variables makes the encoder about 9% faster.
<span class="fc" id="L606">            final byte[] alphabet = this.alphabet;</span>
<span class="fc" id="L607">            final byte[] output = this.output;</span>
<span class="fc" id="L608">            int op = 0;</span>
<span class="fc" id="L609">            int count = this.count;</span>

<span class="fc" id="L611">            int p = offset;</span>
<span class="fc" id="L612">            len += offset;</span>
<span class="fc" id="L613">            int v = -1;</span>

            // First we need to concatenate the tail of the previous call
            // with any input bytes available now and see if we can empty
            // the tail.

<span class="pc bpc" id="L619" title="3 of 4 branches missed.">            switch (tailLen) {</span>
                case 0:
                    // There was no tail.
<span class="fc" id="L622">                    break;</span>

                case 1:
<span class="nc bnc" id="L625" title="All 2 branches missed.">                    if (p + 2 &lt;= len) {</span>
                        // A 1-byte tail with at least 2 bytes of
                        // input available now.
<span class="nc" id="L628">                        v = ((tail[0] &amp; 0xff) &lt;&lt; 16) |</span>
                                ((input[p++] &amp; 0xff) &lt;&lt; 8) |
                                (input[p++] &amp; 0xff);
<span class="nc" id="L631">                        tailLen = 0;</span>
                    }
                    ;
                    break;

                case 2:
<span class="nc bnc" id="L637" title="All 2 branches missed.">                    if (p + 1 &lt;= len) {</span>
                        // A 2-byte tail with at least 1 byte of input.
<span class="nc" id="L639">                        v = ((tail[0] &amp; 0xff) &lt;&lt; 16) |</span>
                                ((tail[1] &amp; 0xff) &lt;&lt; 8) |
                                (input[p++] &amp; 0xff);
<span class="nc" id="L642">                        tailLen = 0;</span>
                    }
                    break;
            }

<span class="pc bpc" id="L647" title="1 of 2 branches missed.">            if (v != -1) {</span>
<span class="nc" id="L648">                output[op++] = alphabet[(v &gt;&gt; 18) &amp; 0x3f];</span>
<span class="nc" id="L649">                output[op++] = alphabet[(v &gt;&gt; 12) &amp; 0x3f];</span>
<span class="nc" id="L650">                output[op++] = alphabet[(v &gt;&gt; 6) &amp; 0x3f];</span>
<span class="nc" id="L651">                output[op++] = alphabet[v &amp; 0x3f];</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">                if (--count == 0) {</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">                    if (do_cr) output[op++] = '\r';</span>
<span class="nc" id="L654">                    output[op++] = '\n';</span>
<span class="nc" id="L655">                    count = LINE_GROUPS;</span>
                }
            }

            // At this point either there is no tail, or there are fewer
            // than 3 bytes of input available.

            // The main loop, turning 3 input bytes into 4 output bytes on
            // each iteration.
<span class="fc bfc" id="L664" title="All 2 branches covered.">            while (p + 3 &lt;= len) {</span>
<span class="fc" id="L665">                v = ((input[p] &amp; 0xff) &lt;&lt; 16) |</span>
                        ((input[p + 1] &amp; 0xff) &lt;&lt; 8) |
                        (input[p + 2] &amp; 0xff);
<span class="fc" id="L668">                output[op] = alphabet[(v &gt;&gt; 18) &amp; 0x3f];</span>
<span class="fc" id="L669">                output[op + 1] = alphabet[(v &gt;&gt; 12) &amp; 0x3f];</span>
<span class="fc" id="L670">                output[op + 2] = alphabet[(v &gt;&gt; 6) &amp; 0x3f];</span>
<span class="fc" id="L671">                output[op + 3] = alphabet[v &amp; 0x3f];</span>
<span class="fc" id="L672">                p += 3;</span>
<span class="fc" id="L673">                op += 4;</span>
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">                if (--count == 0) {</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">                    if (do_cr) output[op++] = '\r';</span>
<span class="nc" id="L676">                    output[op++] = '\n';</span>
<span class="nc" id="L677">                    count = LINE_GROUPS;</span>
                }
            }

<span class="pc bpc" id="L681" title="1 of 2 branches missed.">            if (finish) {</span>
                // Finish up the tail of the input.  Note that we need to
                // consume any bytes in tail before any bytes
                // remaining in input; there should be at most two bytes
                // total.

<span class="fc bfc" id="L687" title="All 2 branches covered.">                if (p - tailLen == len - 1) {</span>
<span class="fc" id="L688">                    int t = 0;</span>
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">                    v = ((tailLen &gt; 0 ? tail[t++] : input[p++]) &amp; 0xff) &lt;&lt; 4;</span>
<span class="fc" id="L690">                    tailLen -= t;</span>
<span class="fc" id="L691">                    output[op++] = alphabet[(v &gt;&gt; 6) &amp; 0x3f];</span>
<span class="fc" id="L692">                    output[op++] = alphabet[v &amp; 0x3f];</span>
<span class="fc bfc" id="L693" title="All 2 branches covered.">                    if (do_padding) {</span>
<span class="fc" id="L694">                        output[op++] = '=';</span>
<span class="fc" id="L695">                        output[op++] = '=';</span>
                    }
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">                    if (do_newline) {</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">                        if (do_cr) output[op++] = '\r';</span>
<span class="fc" id="L699">                        output[op++] = '\n';</span>
                    }
<span class="fc bfc" id="L701" title="All 2 branches covered.">                } else if (p - tailLen == len - 2) {</span>
<span class="fc" id="L702">                    int t = 0;</span>
<span class="pc bpc" id="L703" title="1 of 2 branches missed.">                    v = (((tailLen &gt; 1 ? tail[t++] : input[p++]) &amp; 0xff) &lt;&lt; 10) |</span>
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">                            (((tailLen &gt; 0 ? tail[t++] : input[p++]) &amp; 0xff) &lt;&lt; 2);</span>
<span class="fc" id="L705">                    tailLen -= t;</span>
<span class="fc" id="L706">                    output[op++] = alphabet[(v &gt;&gt; 12) &amp; 0x3f];</span>
<span class="fc" id="L707">                    output[op++] = alphabet[(v &gt;&gt; 6) &amp; 0x3f];</span>
<span class="fc" id="L708">                    output[op++] = alphabet[v &amp; 0x3f];</span>
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">                    if (do_padding) {</span>
<span class="fc" id="L710">                        output[op++] = '=';</span>
                    }
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">                    if (do_newline) {</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">                        if (do_cr) output[op++] = '\r';</span>
<span class="nc" id="L714">                        output[op++] = '\n';</span>
                    }
<span class="pc bpc" id="L716" title="4 of 6 branches missed.">                } else if (do_newline &amp;&amp; op &gt; 0 &amp;&amp; count != LINE_GROUPS) {</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">                    if (do_cr) output[op++] = '\r';</span>
<span class="nc" id="L718">                    output[op++] = '\n';</span>
                }

<span class="pc bpc" id="L721" title="1 of 2 branches missed.">                assert tailLen == 0;</span>
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">                assert p == len;</span>
            } else {
                // Save the leftovers in tail to be consumed on the next
                // call to encodeInternal.

<span class="nc bnc" id="L727" title="All 2 branches missed.">                if (p == len - 1) {</span>
<span class="nc" id="L728">                    tail[tailLen++] = input[p];</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">                } else if (p == len - 2) {</span>
<span class="nc" id="L730">                    tail[tailLen++] = input[p];</span>
<span class="nc" id="L731">                    tail[tailLen++] = input[p + 1];</span>
                }
            }

<span class="fc" id="L735">            this.op = op;</span>
<span class="fc" id="L736">            this.count = count;</span>

<span class="fc" id="L738">            return true;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>