<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ProfanityConsumer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">cb-discussion-service</a> &gt; <a href="index.source.html" class="el_package">com.igot.cb.profanity.consumer</a> &gt; <span class="el_source">ProfanityConsumer.java</span></div><h1>ProfanityConsumer.java</h1><pre class="source lang-java linenums">package com.igot.cb.profanity.consumer;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.igot.cb.discussion.entity.DiscussionAnswerPostReplyEntity;
import com.igot.cb.discussion.entity.DiscussionEntity;
import com.igot.cb.discussion.repository.DiscussionAnswerPostReplyRepository;
import com.igot.cb.discussion.repository.DiscussionRepository;
import com.igot.cb.discussion.service.DiscussionService;
import com.igot.cb.notificationUtill.HelperMethodService;
import com.igot.cb.notificationUtill.NotificationTriggerService;
import com.igot.cb.pores.elasticsearch.dto.SearchResult;
import com.igot.cb.pores.elasticsearch.service.EsUtilService;
import com.igot.cb.pores.util.CbServerProperties;
import com.igot.cb.pores.util.Constants;
import com.igot.cb.transactional.cassandrautils.CassandraOperation;
import lombok.extern.slf4j.Slf4j;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import java.util.*;
import java.util.concurrent.CompletableFuture;

import static com.igot.cb.pores.util.Constants.*;

@Component
<span class="fc" id="L35">@Slf4j</span>
<span class="fc" id="L36">public class ProfanityConsumer {</span>

    @Autowired
    private ObjectMapper mapper;

    @Autowired
    private DiscussionRepository discussionRepository;

    @Autowired
    private EsUtilService esUtilService;

    @Autowired
    private CbServerProperties cbServerProperties;

    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private DiscussionService discussionService;

    @Autowired
    private CassandraOperation cassandraOperation;

    @Autowired
    @Qualifier(Constants.SEARCH_RESULT_REDIS_TEMPLATE)
    private RedisTemplate&lt;String, SearchResult&gt; redisTemplate;

    @Autowired
    private DiscussionAnswerPostReplyRepository discussionAnswerPostReplyRepository;

    @Autowired
    private NotificationTriggerService notificationTriggerService;

    @Autowired
    private HelperMethodService helperMethodService;

    /**
     * Kafka listener for processing profanity check messages.
     * Extracts contentId and isProfane from the message and updates the discussion record.
     *
     * @param textData the Kafka message containing JSON data
     */
    @KafkaListener(topics = &quot;${kafka.topic.process.check.content.profanity}&quot;, groupId = &quot;${kafka.group.process.check.content.profanity}&quot;)
    public void checkTextContentIsProfane(ConsumerRecord&lt;String, String&gt; textData) {
<span class="fc bfc" id="L80" title="All 2 branches covered.">        if (StringUtils.hasText(textData.value())) {</span>
            try {
<span class="fc" id="L82">                JsonNode textDataNode = mapper.readTree(textData.value());</span>
<span class="fc" id="L83">                String discussionId = textDataNode.path(Constants.REQUEST_DATA).path(Constants.METADATA).path(Constants.POST_ID).asText();</span>
<span class="fc" id="L84">                String type = textDataNode.path(Constants.REQUEST_DATA).path(Constants.METADATA).path(Constants.TYPE).asText();</span>
<span class="fc" id="L85">                boolean isProfane = textDataNode.path(Constants.RESPONSE_DATA).path(Constants.RESPONSE_DATA_PATH).path(Constants.IS_PROFANE).asBoolean(false);</span>
<span class="fc" id="L86">                String profanityResponseJson = textDataNode.toString();</span>
<span class="fc" id="L87">                CompletableFuture.runAsync(() -&gt; {</span>
                    try {
<span class="fc bfc" id="L89" title="All 4 branches covered.">                        if (Constants.QUESTION.equalsIgnoreCase(type) || Constants.ANSWER_POST.equalsIgnoreCase(type)) {</span>
<span class="fc" id="L90">                            discussionRepository.updateProfanityFieldsByDiscussionId(discussionId, profanityResponseJson, isProfane);</span>
<span class="fc" id="L91">                            log.info(&quot;Successfully updated profanity fields for Discussion: {}&quot;, discussionId);</span>
<span class="fc" id="L92">                            syncProfaneDetailsToESForDiscussion(discussionId, isProfane, type);</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">                        } else if (Constants.ANSWER_POST_REPLY.equalsIgnoreCase(type)){</span>
<span class="fc" id="L94">                            discussionAnswerPostReplyRepository.updateProfanityFieldsByDiscussionId(discussionId, profanityResponseJson, isProfane);</span>
<span class="fc" id="L95">                            log.info(&quot;Successfully updated profanity fields for Answer Post Reply: {}&quot;, discussionId);</span>
<span class="fc" id="L96">                            syncProfaneDetailsToESForAnswerPost(discussionId, isProfane, type);</span>
                        }
<span class="fc" id="L98">                    } catch (Exception ex) {</span>
<span class="fc" id="L99">                        log.error(&quot;Failed to update profanity fields for Discussion: {}&quot;, discussionId, ex);</span>
<span class="fc" id="L100">                    }</span>
<span class="fc" id="L101">                });</span>
<span class="fc" id="L102">            } catch (JsonProcessingException e) {</span>
<span class="fc" id="L103">                log.error(&quot;Failed to parse JSON from Kafka message: {}&quot;, textData.value(), e);</span>
<span class="fc" id="L104">            }</span>
        }
<span class="fc" id="L106">    }</span>

    /**
     * Sync the profane details to Elasticsearch and deletes relevant caches.
     *
     * @param discussionId the ID of the discussion
     * @param isProfane    indicates whether the discussion is profane
     * @param type - the type of the post (e.g., question, answerPost)
     */
    private void syncProfaneDetailsToESForDiscussion(String discussionId, boolean isProfane, String type) {
<span class="fc" id="L116">        Optional&lt;DiscussionEntity&gt; discussionEntity = discussionRepository.findById(discussionId);</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">        if (discussionEntity.isPresent()) {</span>
<span class="fc" id="L118">            DiscussionEntity discussionDbData = discussionEntity.get();</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">            if (Boolean.FALSE.equals(discussionDbData.getIsActive())) {</span>
<span class="fc" id="L120">                log.info(&quot;Discussion is inactive, skipping Elasticsearch update for PostId: {}&quot;, discussionId);</span>
            } else {
<span class="fc" id="L122">                ObjectNode data = (ObjectNode) discussionDbData.getData();</span>
<span class="fc" id="L123">                Map&lt;String, Object&gt; map = objectMapper.convertValue(data, new TypeReference&lt;Map&lt;String, Object&gt;&gt;() {</span>
                });
<span class="fc" id="L125">                map.put(Constants.IS_PROFANE, isProfane);</span>
<span class="fc" id="L126">                esUtilService.updateDocument(cbServerProperties.getDiscussionEntity(), discussionDbData.getDiscussionId(), map, cbServerProperties.getElasticDiscussionJsonPath());</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">                if (isProfane) {</span>
<span class="fc" id="L128">                    String userId = discussionDbData.getData().get(&quot;createdBy&quot;).asText();</span>
<span class="fc" id="L129">                    String firstName = helperMethodService.fetchUserFirstName(userId);</span>
<span class="fc" id="L130">                    Map&lt;String, Object&gt; notificationData = Map.of(</span>
<span class="fc" id="L131">                            Constants.COMMUNITY_ID, data.get(Constants.COMMUNITY_ID).asText(),</span>
<span class="fc" id="L132">                            Constants.DISCUSSION_ID, data.get(Constants.DISCUSSION_ID).asText(),</span>
<span class="fc" id="L133">                            IS_PROFANE, true</span>
                    );
<span class="fc" id="L135">                    notificationTriggerService.triggerNotification(Constants.PROFANITY_CHECK, ALERT, Collections.singletonList(userId), TITLE, firstName, notificationData);</span>
                }
            }
<span class="fc" id="L138">        } else {</span>
<span class="fc" id="L139">            log.warn(&quot;Discussion not found for Discussion Id: {}&quot;, discussionId);</span>
        }
<span class="fc" id="L141">    }</span>

    /**
     * Sync the profane details to Elasticsearch for answer post replies and deletes relevant caches.
     *
     * @param discussionId the ID of the discussion answer post reply
     * @param isProfane    indicates whether the answer post reply is profane
     * @param type - the type of the post (e.g., answerPostReply)
     */
    private void syncProfaneDetailsToESForAnswerPost(String discussionId, boolean isProfane, String type) {
<span class="fc" id="L151">        Optional&lt;DiscussionAnswerPostReplyEntity&gt; discussionAnswerPostReplyEntity = discussionAnswerPostReplyRepository.findById(discussionId);</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">        if (discussionAnswerPostReplyEntity.isPresent()) {</span>
<span class="fc" id="L153">            DiscussionAnswerPostReplyEntity discussionAnswerPostReply = discussionAnswerPostReplyEntity.get();</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">            if (Boolean.FALSE.equals(discussionAnswerPostReply.getIsActive())) {</span>
<span class="fc" id="L155">                log.info(&quot;Discussion Answer Post Reply is inactive, skipping Elasticsearch update for PostId: {}&quot;, discussionId);</span>
            } else {
<span class="fc" id="L157">                ObjectNode data = (ObjectNode) discussionAnswerPostReply.getData();</span>
<span class="fc" id="L158">                Map&lt;String, Object&gt; map = objectMapper.convertValue(data, new TypeReference&lt;Map&lt;String, Object&gt;&gt;() {</span>
                });
<span class="fc" id="L160">                map.put(Constants.IS_PROFANE, isProfane);</span>
<span class="fc" id="L161">                esUtilService.updateDocument(cbServerProperties.getDiscussionEntity(), discussionAnswerPostReply.getDiscussionId(), map, cbServerProperties.getElasticDiscussionJsonPath());</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">                if (isProfane) {</span>
<span class="fc" id="L163">                    String userId = discussionAnswerPostReply.getData().get(&quot;createdBy&quot;).asText();</span>
<span class="fc" id="L164">                    String firstName = helperMethodService.fetchUserFirstName(userId);</span>
<span class="fc" id="L165">                    Map&lt;String, Object&gt; notificationData = Map.of(</span>
<span class="fc" id="L166">                            Constants.COMMUNITY_ID, data.get(Constants.COMMUNITY_ID).asText(),</span>
<span class="fc" id="L167">                            Constants.DISCUSSION_ID, data.get(Constants.DISCUSSION_ID).asText(),</span>
<span class="fc" id="L168">                            IS_PROFANE, true</span>
                    );
<span class="fc" id="L170">                    notificationTriggerService.triggerNotification(Constants.PROFANITY_CHECK, ALERT, Collections.singletonList(userId), TITLE, firstName, notificationData);</span>
                }
            }
<span class="fc" id="L173">        } else {</span>
<span class="fc" id="L174">            log.warn(&quot;Discussion Answer Post Reply not found for Discussion Id: {}&quot;, discussionId);</span>
        }
<span class="fc" id="L176">    }</span>

}
 
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>